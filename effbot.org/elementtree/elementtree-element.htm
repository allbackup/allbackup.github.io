<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"><link rel="shortcut icon" href="/media/img/effbot.ico"><link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"><link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"><title>The Element API (Work in&nbsp;Progress)</title></head><body data-page-id="1994"><div id="doc2" class="yui-t2"><div id="hd"></div><div id="bd"><div id="yui-main"><div class="yui-b"><div class="content"><div class="yui-g"><h1 class="maintitle">The Element API (Work in&nbsp;Progress)</h1></div><div class="yui-ge"><div class="yui-u first"><p class="info">Fredrik Lundh | August 2007</p><p>This document describes the <strong>Element</strong> interface.  It covers both the 1.2 releases (including 1.2.6 that&#8217;s included in Python 2.5), and the upcoming 1.3 release.</p><p>Also see <a href="pythondoc-elementtree-ElementTree.htm"><em>The elementtree.ElementTree
Module</em></a>.</p><h2 id="overview">Overview&#160;<a class="nav" href="#overview" title="bookmark!">#</a></h2><h2 id="examples">Examples&#160;<a class="nav" href="#examples" title="bookmark!">#</a></h2><h2 id="tag-ET.Element">The Element Class&#160;<a class="nav" href="#tag-ET.Element" title="bookmark!">#</a></h2><p><strong>Element(tag)</strong> &#8658; element</p><p><strong>Element(tag, name=value, &#8230;)</strong> &#8658; element</p><p>Creates an element instance.  Depending on the implementation, this may be either a factory function or an ordinary class.  It takes an element name (the tag), and, optionally, a number of attribute name/value pairs given as keyword arguments.</p><p>The element name, attribute names, and attribute values can be either 8-bit ASCII strings or Unicode strings.</p><p><strong>Element(tag, attrib)</strong> &#8658; element</p><p><strong>Element(tag, attrib, name=value, &#8230;)</strong> &#8658; element</p><p>Same, but takes a dictionary with attribute name/value pairs.  If you use both a dictionary and keyword name/value pairs, the pairs will override the corresponding key/value pairs from the dictionary.</p><h2 id="tag-ET.SubElement">The SubElement Class&#160;<a class="nav" href="#tag-ET.SubElement" title="bookmark!">#</a></h2><p><strong>SubElement(parent, tag, attrib, name=value, &#8230;)</strong> &#8658; element</p><p>Same as <strong>Element</strong>, but appends the new element to a given parent.</p><h2 id="attributes">Attributes&#160;<a class="nav" href="#attributes" title="bookmark!">#</a></h2><h3 id="tag-ET.Element.tag">tag&#160;<a class="nav" href="#tag-ET.Element.tag" title="bookmark!">#</a></h3><p><strong>elem.tag</strong></p><p>(Attribute) Element tag.  This is either a string or the value None, if there is no text.</p><h3 id="tag-ET.Element.text">text&#160;<a class="nav" href="#tag-ET.Element.text" title="bookmark!">#</a></h3><p><strong>elem.text</strong></p><p>(Attribute) Text before first subelement.  This is either a string or the value None, if there is no text.</p><p>Some implementations set this attribute to an empty string if there is no text, so user code should treat None and an empty string as equivalent.</p><p>Both <strong>ElementTree</strong> and <strong>cElementTree</strong> allow you to assign
other data types to this attribute, something that can be useful when writing de-serialization code.  Not all implementations support this, though, so such code isn&#8217;t fully portable.</p><h3 id="tag-ET.Element.tail">tail&#160;<a class="nav" href="#tag-ET.Element.tail" title="bookmark!">#</a></h3><p><strong>elem.tail</strong></p><p>(Attribute) Text after this element&#8217;s end tag, but before the next sibling element&#8217;s start tag.  This is either a string or the value None, if there is no text.</p><p>See <strong>text</strong> for more information on attribute types and usage.</p><h3 id="tag-ET.Element.attrib">attrib&#160;<a class="nav" href="#tag-ET.Element.attrib" title="bookmark!">#</a></h3><p>(Attribute) A dictionary containing all element attributes.</p><p>Note that some implementations uses custom storage for attributes, and create the dictionary only when needed.  For best performance, use the <strong>get</strong> and <strong>set</strong> methods, when suitable.</p><pre class="python">value = elem.get(<span class="pystring">"attribute"</span>)
value = elem.get(<span class="pystring">"attribute"</span>, <span class="pystring">"default"</span>)
elem.set(<span class="pystring">"attribute"</span>, <span class="pystring">"value"</span>)</pre><p>Note that this attribute shouldn&#8217;t be replaced; the dictionary can be modified, but if you need to replace it, call <strong>clear()</strong> followed by <strong>update()</strong>:</p><pre class="python">elem.attrib.clear()
elem.attrib.update(new_values)</pre><h2 id="methods">Methods&#160;<a class="nav" href="#methods" title="bookmark!">#</a></h2><h3 id="sequence-interface">Sequence Interface&#160;<a class="nav" href="#sequence-interface" title="bookmark!">#</a></h3><p>Element objects behave as a sequence of their direct child
elements, and support all basic sequence operations, including
indexing, slicing and slice assignment, and the <strong>len</strong>
function.</p><p>To iterate over an entire subtree, use the <strong>iter</strong> method
(<strong>getiterator</strong>, in 1.2).</p><p>Note that truth testing falls back on length in the 1.2 series, which makes it a bit impractical; an element is only considered to be true if it has subelements.  The 1.3 series issues a warning in this case, and future versions will most likely treat any element as true. For portability, use <strong>len(elem)</strong> to test for subelements, and use explicit comparisions to None when checking the result of <strong>find</strong>:</p><pre class="python"><span class="pykeyword">if</span> len(elem):
    <span class="pykeyword">print</span> <span class="pystring">"elem has subelements"</span>

e = elem.find(tag)
<span class="pykeyword">if</span> e <span class="pykeyword">is</span> None:
    <span class="pykeyword">print</span> <span class="pystring">"tag not found"</span></pre><h3 id="tag-ET.Element.append">append&#160;<a class="nav" href="#tag-ET.Element.append" title="bookmark!">#</a></h3><p><strong>elem.append(subelement)</strong></p><p>Adds a subelement to the end of this element.  When serialized, the new element will appear just before the end tag for this element.</p><h3 id="tag-ET.Element.extend">extend&#160;<a class="nav" href="#tag-ET.Element.extend" title="bookmark!">#</a></h3><p><strong>elem.extend(sequence)</strong></p><p>Appends subelements from a sequence.  The sequence can be any kind of iterable, including lists, tuples and generators.  If you pass in another element, its children are added.</p><h3 id="tag-ET.Element.insert">insert&#160;<a class="nav" href="#tag-ET.Element.insert" title="bookmark!">#</a></h3><p><strong>elem.insert(index, element)</strong></p><p>Inserts a subelement at the given position in this element.</p><h3 id="tag-ET.Element.remove">remove&#160;<a class="nav" href="#tag-ET.Element.remove" title="bookmark!">#</a></h3><p><strong>elem.remove(subelement)</strong></p><p>Removes a matching subelement.  Unlike the <strong>find</strong> methods,
this method compares elements based on identity, not on tag value or
contents.</p><p>To remove subelements on other conditions, or remove multiple
subelements in one step, use the following pattern:</p><pre class="python">elem[:] = [e <span class="pykeyword">for</span> e <span class="pykeyword">in</span> elem <span class="pykeyword">if</span> condition]</pre><p>Where <em>condition</em> determines if the element should be kept.</p><p>This method raises a <a href="/pyref/ValueError.htm"><strong>ValueError</strong></a> exception if no matching element could be found.</p><h3 id="tag-ET.Element.clear">clear&#160;<a class="nav" href="#tag-ET.Element.clear" title="bookmark!">#</a></h3><p><strong>elem.clear()</strong></p><p>Resets an element.  This function removes all subelements, clears all attributes, and sets the <strong>text</strong> and <strong>tail</strong> attributes to None.</p><h3 id="tag-ET.Element.get">get&#160;<a class="nav" href="#tag-ET.Element.get" title="bookmark!">#</a></h3><p><strong>elem.get(key, default)</strong> &#8658; string or None</p><p>Gets an element attribute.  If the attribute doesn&#8217;t exist, returns the default value, or None if no default was given.</p><p>This is equivalent to <strong>elem.attrib.get(key, default)</strong>.</p><h3 id="tag-ET.Element.set">set&#160;<a class="nav" href="#tag-ET.Element.set" title="bookmark!">#</a></h3><p><strong>elem.set(key, value)</strong></p><p>Sets an element attribute.</p><p>This is equivalent to <strong>elem.attrib[key] = value</strong>.</p><h3 id="tag-ET.Element.keys">keys&#160;<a class="nav" href="#tag-ET.Element.keys" title="bookmark!">#</a></h3><p><strong>elem.keys()</strong> &#8658; sequence</p><p>Gets a list of attribute names.  The names are returned in an
arbitrary order (just like for an ordinary Python dictionary).</p><p>This is equivalent to <strong>elem.attrib.keys()</strong>.</p><h3 id="tag-ET.Element.items">items&#160;<a class="nav" href="#tag-ET.Element.items" title="bookmark!">#</a></h3><p><strong>elem.items()</strong> &#8658; sequence of (string, string) tuples</p><p>Gets element attributes, as (name, value) tuples in a sequence.
The attributes are returned in an arbitrary order.</p><p>This is equivalent to <strong>elem.attrib.items()</strong>.</p><h3 id="tag-ET.Element.iter">iter&#160;<a class="nav" href="#tag-ET.Element.iter" title="bookmark!">#</a></h3><p><strong>elem.iter()</strong> &#8658; iterator</p><p><strong>elem.iter(tag)</strong> &#8658; iterator</p><p>(New in 1.3) Creates a tree iterator.  The iterator loops over this element and all subelements, in document order, and returns all elements with a matching tag.  If the tag is omitted, all elements are returned.</p><p>If the tree structure is modified during iteration, the result is undefined.</p><p>To loop over all matching subelements, except the element itself, use <strong>elem.findall(&#8220;.//&#8221; + tag)</strong>.</p><p>Note that this method was renamed in 1.3.  In earlier releases, use the <strong>getiterator</strong> name instead.  The old name is still available, for compatibility only.</p><h3 id="tag-ET.Element.itertext">itertext&#160;<a class="nav" href="#tag-ET.Element.itertext" title="bookmark!">#</a></h3><p><strong>elem.itertext()</strong> &#8658; iterator</p><p>(New in 1.3) Creates a text fragment iterator.  The iterator loops over this element and all subelements, in document order, and returns all inner text.</p><p>To get all inner text as a single string, you can use:</p><pre class="python">text = <span class="pystring">""</span>.join(elem.itertext())</pre><p>If the tree structure is modified during iteration, the result is undefined.</p><p>The inner text is defined as the text attributes for the given element, and the text and tail attributes for all subelements, returned in document order.  An implementation may omit empty text fragments, and may merge multiple fragments into a single string, or split long strings into more than one fragment.</p><h3 id="tag-ET.Element.find">find&#160;<a class="nav" href="#tag-ET.Element.find" title="bookmark!">#</a></h3><p><strong>elem.find(path)</strong> &#8658; element or None</p><p>Finds the first matching subelement, by tag name or path.</p><p><strong>elem.find(path, namespaces=dictionary)</strong> &#8658; element or None</p><p>(New in 1.3) Same, but uses the given dictionary to map prefixes to namespace URI:s.</p><h3 id="tag-ET.Element.findall">findall&#160;<a class="nav" href="#tag-ET.Element.findall" title="bookmark!">#</a></h3><p><strong>elem.findall(path)</strong> &#8658; list</p><p>Finds all matching subelements, by tag name or path.</p><p><strong>elem.findall(path, namespaces=dictionary)</strong> &#8658; list</p><p>(New in 1.3) Same, but uses the given dictionary to map prefixes to namespace URI:s</p><h3 id="tag-ET.Element.iterfind">iterfind&#160;<a class="nav" href="#tag-ET.Element.iterfind" title="bookmark!">#</a></h3><p><strong>elem.iterfind(path)</strong> &#8658; iterator</p><p>Same as <strong>findall</strong>, but returns an iterator.</p><h3 id="tag-ET.Element.findtext">findtext&#160;<a class="nav" href="#tag-ET.Element.findtext" title="bookmark!">#</a></h3><p><strong>elem.findtext(path)</strong> &#8658; text</p><p><strong>elem.findtext(path, default)</strong> &#8658; text</p><p>Finds text for the first matching subelement, by tag name or path. If no matching element can be found, this method return the default value, or None if no default was given.</p><p>If the element is found, but has no text content, this method
returns an empty string.</p><p>Note that this method returns the contents of the <strong>text</strong> for
the first matching element only; it does not traverse the tree. To get all internal text, you can use something like:</p><pre class="python"><span class="pykeyword">def</span> <span class="pyfunction">gettext</span>(elem):
    text = elem.text <span class="pykeyword">or</span> <span class="pystring">""</span>
    <span class="pykeyword">for</span> e <span class="pykeyword">in</span> elem:
        text += gettext(e)
        <span class="pykeyword">if</span> e.tail:
            text += e.tail
    <span class="pykeyword">return</span> text</pre><p><strong>elem.findtext(path, namespaces=dictionary)</strong> &#8658; text</p><p><strong>elem.findtext(path, default, namespaces=dictionary)</strong> &#8658; text</p><p>(New in 1.3) Same, but uses the given dictionary to map prefixes to namespace URI:s</p><h3 id="tag-ET.Element.getchildren">getchildren&#160;<a class="nav" href="#tag-ET.Element.getchildren" title="bookmark!">#</a></h3><p><strong>elem.getchildren()</strong> &#8658; list of elements</p><p>(Deprecated) Returns all child elements.  The elements are returned in document order.</p><p>Note that since elements are containers, you can just loop over an element to get its child elements.  To get a list of all subelements, use <strong>list(elem)</strong>.</p><h3 id="tag-ET.Element.getiterator">getiterator&#160;<a class="nav" href="#tag-ET.Element.getiterator" title="bookmark!">#</a></h3><p><strong>elem.getiterator()</strong> &#8658; iterator</p><p><strong>elem.getiterator(tag)</strong> &#8658; iterator</p><p>(Deprecated) Same as <strong>iter</strong>.</p><p>Note that this method is deprecated.  New code should use the shorter name, unless compatibility with pre-1.3 versions (e.g. the version shipped with Python 2.5) is important.</p><h3 id="tag-ET.Element.makeelement">makeelement&#160;<a class="nav" href="#tag-ET.Element.makeelement" title="bookmark!">#</a></h3><p><strong>elem.makeelement(tag, attrib)</strong> &#8658; element</p><p>Creates a new element object of the same type as this element.  Both the tag and the attribute dictionary must be given; this method does not support keyword arguments.</p><p>This method is mainly provided for code that builds element structures from other sources; user code can usually use the <strong>Element</strong> or <strong>SubElement</strong> to create new elements.</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"></div></div></div></div><div class="yui-b"><div id='menu'><ul><li><b><a href="/" title="Go to effbot.org.">::: effbot.org</a></b></li><li><b><a href="." title="Go to elementtree index page.">::: elementtree :::</a></b></li></ul><ul><li><b>::: contents</b></li></ul><ul><li><ul><li><a href="#overview">Overview</a></li><li><a href="#examples">Examples</a></li><li><a href="#tag-ET.Element">The Element Class</a></li><li><a href="#tag-ET.SubElement">The SubElement Class</a></li><li><a href="#attributes">Attributes</a></li><li><ul><li><a href="#tag-ET.Element.tag">tag</a></li><li><a href="#tag-ET.Element.text">text</a></li><li><a href="#tag-ET.Element.tail">tail</a></li><li><a href="#tag-ET.Element.attrib">attrib</a></li></ul></li><li><a href="#methods">Methods</a></li><li><ul><li><a href="#sequence-interface">Sequence Interface</a></li><li><a href="#tag-ET.Element.append">append</a></li><li><a href="#tag-ET.Element.extend">extend</a></li><li><a href="#tag-ET.Element.insert">insert</a></li><li><a href="#tag-ET.Element.remove">remove</a></li><li><a href="#tag-ET.Element.clear">clear</a></li><li><a href="#tag-ET.Element.get">get</a></li><li><a href="#tag-ET.Element.set">set</a></li><li><a href="#tag-ET.Element.keys">keys</a></li><li><a href="#tag-ET.Element.items">items</a></li><li><a href="#tag-ET.Element.iter">iter</a></li><li><a href="#tag-ET.Element.itertext">itertext</a></li><li><a href="#tag-ET.Element.find">find</a></li><li><a href="#tag-ET.Element.findall">findall</a></li><li><a href="#tag-ET.Element.iterfind">iterfind</a></li><li><a href="#tag-ET.Element.findtext">findtext</a></li><li><a href="#tag-ET.Element.getchildren">getchildren</a></li><li><a href="#tag-ET.Element.getiterator">getiterator</a></li><li><a href="#tag-ET.Element.makeelement">makeelement</a></li></ul></li></ul></li></ul></div></div></div><div id="ft"><p><a href="http://www.djangoproject.com/"><img src="/media/img/djangosite80x15.gif" border="0" alt="A Django site." title="A Django site." style="vertical-align: bottom;" width="80" height="15" ></a>
rendered by a <a href="http://www.djangoproject.com/">django</a> application.  hosted by <a href="http://www.webfaction.com/shared_hosting?affiliate=slab">webfaction</a>.</p></div></div><script src="/media/js/effbot-min.js" type="text/javascript"></script></body></html>
