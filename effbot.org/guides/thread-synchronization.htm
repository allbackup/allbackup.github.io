<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"> <link rel="shortcut icon" href="/media/img/effbot.ico"> <link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"> <link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"> <title>Thread Synchronization Mechanisms in&nbsp;Python</title> <script type="text/javascript">effbot_page_id=289;</script> </head> <body> <div id="doc2" class="yui-t2"> <div id="hd"> <!-- header --> <!--
<p style='color: #8f8f8f; background: #fff5bf; padding: 5px 10px;'> <b>2008-07-15:</b> Selected articles
 (including this one) 
now have experimental "comment" links in the left column and at the bottom.
You're welcome to use them for commenting and voting on articles.
For a bit more on this, see <a
href="http://effbot.slinkset.com/links/Welcome_to_discuss_effbot_org">this
page</a>. /F
</p>
--> </div> <!-- hd --> <div id="bd"> <!-- body --> <div id="yui-main"> <div class="yui-b"> <div class="content"><div class="yui-g"> <h1 class="maintitle">Thread Synchronization Mechanisms in&nbsp;Python</h1> </div> <!-- yui-g --><div class="yui-ge"><div class="yui-u first"><p class="info">Fredrik Lundh | July 2007</p><p>This article discusses how to synchronize access to shared resources, and otherwise coordinate execution of threads.</p><h2 id="synchronizing-access-to-shared-resources">Synchronizing Access to Shared Resources&#160;<a class="nav" href="#synchronizing-access-to-shared-resources" title="bookmark!">#</a></h2><p>One important issue when using threads is to avoid conflicts when more than one thread needs to access a single variable or other resource.  If you&#8217;re not careful, overlapping accesses or modifications from multiple threads may cause all kinds of problems, and what&#8217;s worse, those problems have a tendency of appearing only under heavy load, or on your production servers, or on some faster hardware that&#8217;s only used by one of your customers.</p><p>For example, consider a program that does some kind of processing, and keeps track of how many items it has processed:</p><pre class="python">counter = 0

<span class="pykeyword">def</span> <span class="pyfunction">process_item</span>(item):
    <span class="pykeyword">global</span> counter
    ... do something <span class="pykeyword">with</span> item ...
    counter += 1</pre><p>If you call this function from more than one thread, you&#8217;ll find that the counter isn&#8217;t necessarily accurate.  It works in most cases, but sometimes misses one or more items.  The reason for this is that the increment operation is actually executed in three steps; first, the interpreter fetches the current value of the counter, then it calculates the new value, and finally, it writes the new value back to the variable.</p><p>If another thread gets control after the current thread has fetched the variable, it may fetch the variable, increment it, and write it back, <em>before</em> the current thread does the same thing.  And since they&#8217;re both seeing the same original value, only one item will be accounted for.</p><p>Another common problem is access to incomplete or inconsistent state, which can happen if one thread is initializing or updating some non-trivial data structure, and another thread attempts to read the structure while it&#8217;s being updated.</p><h3 id="atomic-operations">Atomic Operations&#160;<a class="nav" href="#atomic-operations" title="bookmark!">#</a></h3><p>The simplest way to synchronize access to shared variables or other resources is to rely on atomic operations in the interpreter.  An atomic operation is an operation that is carried out in a single execution step, without any chance that another thread gets control.</p><p>In general, this approach only works if the shared resource consists of a single instance of a core data type, such as a string variable, a number, or a list or dictionary.  Here are some thread-safe operations:</p><ul><li>reading or replacing a single instance attribute</li><li>reading or replacing a single global variable</li><li>fetching an item from a list</li><li>modifying a list in place (e.g. adding an item using <strong>append</strong>)</li><li>fetching an item from a dictionary</li><li>modifying a dictionary in place (e.g. adding an item, or calling the <strong>clear</strong> method)</li></ul><p>Note that as mentioned earlier, operations that read a variable or attribute, modifies it, and then writes it back are not thread-safe.  Another thread may update the variable after it&#8217;s been read by the current thread, but before it&#8217;s been updated.</p><p>Also note that Python code may be executed when objects are destroyed, so even seemingly simple operations may cause other threads to run, and may thus cause conflicts.  When in doubt, use explicit locks.</p><h3 id="locks">Locks&#160;<a class="nav" href="#locks" title="bookmark!">#</a></h3><p>Locks are the most fundamental synchronization mechanism provided by the <b>threading</b> module.  At any time, a lock can be held by a single thread, or by no thread at all.  If a thread attempts to hold a lock that&#8217;s already held by some other thread, execution of the first thread is halted until the lock is released.</p><p>Locks are typically used to synchronize access to a shared resource.  For each shared resource, create a <b>Lock</b> object.  When you need to access the resource, call <b>acquire</b> to hold the lock (this will wait for the lock to be released, if necessary), and call <b>release</b> to release it:</p><pre class="python">lock = Lock()

lock.acquire() <span class="pycomment"># will block if lock is already held</span>
... access shared resource
lock.release()</pre><p>For proper operation, it&#8217;s important to release the lock even if something goes wrong when accessing the resource.  You can use <strong>try-finally</strong> for this purpose:</p><pre class="python">lock.acquire()
<span class="pykeyword">try</span>:
    ... access shared resource
<span class="pykeyword">finally</span>:
    lock.release() <span class="pycomment"># release lock, no matter what</span></pre><p>In Python 2.5 and later, you can also use the <strong>with</strong> statement.  When used with a lock, this statement automatically acquires the lock before entering the block, and releases it when leaving the block:</p><pre class="python"><span class="pykeyword">from</span> __future__ <span class="pykeyword">import</span> with_statement <span class="pycomment"># 2.5 only</span>

<span class="pykeyword">with</span> lock:
    ... access shared resource</pre><p>The <b>acquire</b> method 