<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"><link rel="shortcut icon" href="/media/img/effbot.ico"><link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"><link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"><title>Some Notes on Moving the Zone to&nbsp;Django</title></head><body data-page-id="2"><div id="doc2" class="yui-t2"><div id="hd"></div><div id="bd"><div id="yui-main"><div class="yui-b"><div class="content"><div class="yui-g"><h1 class="maintitle">Some Notes on Moving the Zone to&nbsp;Django</h1></div><div class="yui-ge"><div class="yui-u first"><p class="info">Fredrik Lundh | August 2007</p><p class="note"><b>Updated 2007-08-20:</b> Added sections on caching and resource &#8220;minification&#8221;.</p><p>The effbot.org &#8220;zone&#8221; is a constantly growing collection of documents, most of them concerning various aspects of Python and related technologies.  The zone software is also used for my <a href="/imagingbook">PIL</a> and <a href="/tkinterbook">Tkinter</a> documentation, the online edition of my <a href="/librarybook">Python Standard Library</a> book, and a couple of other document collections.</p><p>All in all, the zones at effbot.org currently contain around 2,000 documents, plus some 500 user comments.</p><p>Until now, the zone has been served as static HTML, generated and maintained using an increasinly disorganized collection of CGI scripts and off-site tools.  Given that we moved <a href="http://www.pythonware.com">pythonware.com</a> to <a href="http://www.djangoproject.com">Django</a> late last year, it&#8217;s about time I did the same to effbot.org.</p><h2 id="design">Design&#160;<a class="nav" href="#design" title="bookmark!">#</a></h2><p>My original plan was to use the old effbot.org templates pretty much as they were, but all recent talk about <s><a href="http://www.subtraction.com/archives/2007/0807_the_framewor.php">CSS frameworks</a></s> (dead link), and how they&#8217;d ruin the field of web design by leaving it open for people who just cannot be bothered to learn everything there is to know about cross-platform CSS inanities, made me curious.  I grabbed a copy of the <a href="http://developer.yahoo.com/yui/">Yahoo! User Interface Library</a>, and went to work.  I set up the following requirements:</p><ul><li>No radical redesign; the new site should look similar to the old one.</li><li>Identical look for a majority of my visitors &#8212; in other words, for IE and Firefox.</li><li>Scalable layout in both IE and Firefox.  Most importantly, <em>increasing</em> the font size should work well (for people with reduced eye-sight or high-DPI displays).</li><li>Support for 80-column wide code samples.</li><li>The site should be fully usable with CSS disabled.</li></ul><p>Implementing this on YUI was surprisingly easy.  The current design use a 950px wide base layout, with a 180px navigation column to the left.  The remaining space is split into two parts, with around 550px effective space (3/4) for the main column, and 180px (1/4) for a sidebar column to the right.  Document blocks can be placed in the sidebar or the main column, or they can cover both columns.  A combination of class names and render heuristics is used to handle block placement. Some source-code examples:</p><pre><code>&lt;p class="sidebar"&gt;This text goes into the
sidebar.&lt;/p&gt;

&lt;p&gt;This goes into the main column.&lt;/p&gt;

&lt;pre class="wide"&gt;
This wide code example extends into the sidebar.
&lt;/pre&gt;
</code></pre><p>The &#8220;wide&#8221; class is automatically added to wide PRE sections (currently, the limit is 55 characters).  A wide column is wide enough to hold just over 80 columns of preformatted text.</p><h3 id="aiming-for-typographic-perfection">Aiming for Typographic Perfection&#160;<a class="nav" href="#aiming-for-typographic-perfection" title="bookmark!">#</a></h3><p>I experimented a little with Chad Miller&#8217;s <a href="http://web.chad.org/projects/smartypants.py/">SmartyPants</a> implementation for Python in the final rendering step, but it was horribly slow &#8212; at least compared to the rest of the rendering chain.  I ended up applying this during conversion to the intermediate format instead.</p><p>(I haven&#8217;t looked at the code, but it seems to me as if it should be possible to apply the SmartyPants algorithms to the existing Element tree, rather than having to serialize the document and then run it through SmartyPants&#8217; home-grown HTML parser).</p><p>I&#8217;m also doing some microtuning in the rendering stage, including inserting hard spaces in titles to keep the last few words together, trimming off trailing whitespace in PRE CODE sections, etc.</p><h2 id="performance">Performance&#160;<a class="nav" href="#performance" title="bookmark!">#</a></h2><p>The effbot.org site isn&#8217;t exactly a high-traffic site, but since I&#8217;m interested in performance and scalability issues, I set up some basic requirements:</p><ul><li>Efficient data transfer to client (support for compression, validation/conditional requests, etc).</li><li>Efficient caching</li><li>Efficient dynamic rendering on cache misses</li></ul><p>Django provides middleware for compression (GZipMiddleware), validation (ConditionalGetMiddleware), and caching (CacheMiddleware).  The only problem was to apply them in the right order (see below for more on this).</p><p>Rendering required a bit more code.  Zone sources are provided in a number of formats, but they&#8217;re primarily written in an HTML subset (just the &lt;body&gt; contents) and in Markdown with some Infogami-style extensions.  Metadata is extracted from the source documents, which makes it easy to author zone documents in pretty much any text editor.</p><p>To speed up rendering, the new system converts from the source to an intermediate XML format when documents are added to the database (via a <strong>save</strong> override on the relevant model).  The intermediate format is then turned into proper HTML and pushed through Django templates on the fly.</p><p>The intermediate format is basically an XHTML document, with the following extensions:</p><ul><li>Support for dynamic titles (fetched from the target on demand)</li><li>Support for inline images.</li><li>Support for local menus (based on headings on page).</li><li>Support for intelligent links.</li><li>Support for program code colorization.</li></ul><p>Inline images are stored as data URI:s in the intermediate format (and usually also in the source documents), but since not all browsers support this format, the renderer replaces the data URI:s with HTTP pointers to an image cache directory.  To distinguish between images, their MD5 hash is used.</p><p>Intelligent links are links that point to &#8220;target subjects&#8221;, rather than specific pages.  For example, a link can point to the &#8220;subprocess&#8221; module, or even to the &#8220;insert&#8221; method of the &#8220;Text&#8221; class in the &#8220;tkinter&#8221; module.  The renderer maps these to suitable on-site locations on the fly.</p><p>The current renderer can produce the equivalent of 2-5 A4 pages per millisecond, which means that most documents on the site render in a few milliseconds on a lightly loaded server, at the most. (FIXME: This is no longer true; for example, the YUI tree restructuring and code colorization is currently done during the final rendering step, and that processing is somewhat costly.  I&#8217;ll move that to the preprocessing stage when I find the time.)</p><h2 id="some-performance-observations">Some Performance Observations&#160;<a class="nav" href="#some-performance-observations" title="bookmark!">#</a></h2><h3 id="middleware-order">Middleware Order&#160;<a class="nav" href="#middleware-order" title="bookmark!">#</a></h3><p>As noted above, getting the middleware order right can be tricky.  Especially the ConditionalGetMiddleware component kept messing things up for me.  With that middleware in the wrong place, the server kept locking up at times.  After a few failed attempts, I finally came up with the following order:</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"><pre class="python wide wide">MIDDLEWARE_CLASSES = (
  <span class="pystring">'django.middleware.common.CommonMiddleware'</span>,
  <span class="pystring">'django.contrib.sessions.middleware.SessionMiddleware'</span>,
  <span class="pystring">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,
  <span class="pystring">'django.middleware.cache.CacheMiddleware'</span>,
  <span class="pystring">'django.middleware.http.ConditionalGetMiddleware'</span>,
  <span class="pystring">'django.middleware.gzip.GZipMiddleware'</span>,
  <span class="pycomment"># custom middleware follows...</span>
)</pre></div><div class="yui-ge"><div class="yui-u first"><p>(This may be documented somewhere in the Django documentation, but I sure couldn&#8217;t find that place.)</p><p>I&#8217;m also using some non-standard middleware components, including my own <a href="django-multihost.htm">multihost</a> middleware, to co-host the development sandbox, online.effbot.org, and
a few other sites on a single Django instance.</p><h3 id="accessing-large-database-records">Accessing Large Database Records&#160;<a class="nav" href="#accessing-large-database-records" title="bookmark!">#</a></h3><p>Both the source document and the intermediate XML version are stored as TextField:s in a big un-normalized table, which also holds associated data such as titles, publication date, etc.  This design might be simple and practical, and un-normalized tables have plenty of performance advantages when the data is relatively static, but a drawback is that it&#8217;s rather expensive to pull out an object from this table via Django&#8217;s ORM; even if you&#8217;re only looking for a couple of metadata attributes, Django will fetch the entire row.</p><p>I was about to change the data model when I remembered the <strong>values</strong> method.  This method tells the ORM what fields you&#8217;re interested in, and returns <em>only</em> those, in an ordinary dictionary.</p><pre class="python">query = SomeModel.objects.filter(key=value)
<span class="pykeyword">for</span> obj <span class="pykeyword">in</span> query:
    do_something(obj.title) <span class="pycomment"># slow</span></pre><p>Becomes:</p><pre class="python">query = SomeModel.objects.filter(key=value)
<span class="pykeyword">for</span> obj <span class="pykeyword">in</span> query.values(<span class="pystring">"title"</span>):
    do_something(obj[<span class="pystring">"title"</span>]) <span class="pycomment"># fast</span></pre><p>You obviously don&#8217;t get all the functionality of your model implementation when you use <strong>values</strong>, but you get the data you&#8217;re after without any extra overhead.  With query sets containing hundreds of documents, some operations took well over a second without <strong>values</strong>, and less than ten milliseconds with it.</p><h3 id="django-caching">Django Caching&#160;<a class="nav" href="#django-caching" title="bookmark!">#</a></h3><p>I&#8217;ve played with both the file cache and <strong>memcached</strong>, and seem to get roughly the same performance with both backends (which is a bit surprising).</p><p>I&#8217;m currently using <strong>memcached</strong>; after all, it &#8220;should&#8221; be faster, and is definitely not slower.  I&#8217;m a little concerned about <a href="http://forum.webfaction.com/viewtopic.php?pid=2311">memory usage</a>, though.  Given that I&#8217;m running this on a shared account, memory is somewhat tight; there&#8217;s a balance between how much memory you can spend on caching, and how much you can spend on Apache processes (see below).</p><p>Some useful resources:</p><ul><li><a href="http://www.gomez.com/info_center/instant_test.php">Gomez Instant Site Test</a> lets you check performance from a few remote sites (or from thousands of them, if you&#8217;re prepared to pay for the service).</li><li>The <a href="http://www.getfirebug.com">Firebug</a> extension to Firefox can be used to check performance from your own systems, and a lot more &#8212; that and the Web Developer toolbar has helped me keep my sanity during deployment.</li><li>The <a href="http://developer.yahoo.com/yslow/">YSlow</a> add-on can be used for additional performance analysis, including a simple &#8220;performance grade&#8221; analysis tool (effbot.org currently gets an &#8220;A&#8221;, python.org an &#8220;F&#8221; ;-)</li></ul><h3 id="media-caching">Media Caching&#160;<a class="nav" href="#media-caching" title="bookmark!">#</a></h3><p>I had some difficulties getting proper caching for static media resources (which are served by a separate Apache instance).  As it turned out, the copy of Firefox that I used for testing had caching turned off under <strong>about:config</strong> (d&#8217;oh!), but Apache didn&#8217;t produce proper headers either.  Fixing the latter was almost as easy as fixing the former (and a lot easier to discover); adding the following <strong>.htaccess</strong>-file to the <strong>media</strong> root directory did the trick:</p><pre><code>&lt;IfModule mod_expires.c&gt;
  ExpiresActive on
  ExpiresDefault "access plus 1 days"
&lt;/IfModule&gt;
</code></pre><p>With this and ConditionalGetMiddleware in place, the server now generates proper expiry- and cache-control headers, and validation requests work as expected.</p><p>(By the way, Mark Nottingham&#8217;s <a href="http://www.mnot.net/cacheability/">Cacheability Engine</a> is a very useful tool for analyzing cache behaviour).</p><h3 id="server-crowding">Server Crowding&#160;<a class="nav" href="#server-crowding" title="bookmark!">#</a></h3><p>This kind of careful up-front design doesn&#8217;t help if you&#8217;re sharing your server with a bunch of Zope applications, though ;-)</p><p>The day before the new site went live, both the staging server
and our other sites all slowed down to crawl, and even started to cause browser timeouts.  <strong>top</strong> told me that a bunch of Zope instances and the <strong>mysql</strong> server kept hogging the CPU:s (with sustained loads in the 80-110% range), and the overall server load was often 10 or above.  And when this happened, it took seconds to fetch a new page from my server.  Tens of seconds, at times.</p><p>My <a href="http://www.webfaction.com/shared_hosting?affiliate=slab">hosting provider</a> set up a new account on a less crowded server, but also spent some time tuning the current server; most importantly, they:</p><ul><li>Made sure that the front-end Apache server had enough
processes available to handle everyone on the machine.</li><li>Increased the ServerLimit setting for my private Apache
instance (the one that&#8217;s running Django).</li></ul><p>When I&#8217;m writing this, the old server is about as quick as a server can be.  I haven&#8217;t ruled out a move, but it&#8217;s not very likely.  We&#8217;ll see.</p><h3 id="resource-minification">Resource Minification&#160;<a class="nav" href="#resource-minification" title="bookmark!">#</a></h3><p>Reducing the number of external resources is a good way to eliminate some overhead.  Since every server request has a cost, it&#8217;s a good idea to eliminate requests if you can.</p><p>The original design used four CSS files, and a few small JavaScript snippets for some unintrusive enhancements (see if you can spot them ;-).  I&#8217;ve now combined the screen CSS files, and &#8220;minified&#8221; all resources.</p><p>For JavaScript minification, I use Baruch Even&#8217;s Python port of <a href="http://www.crockford.com/javascript/jsmin.html">JSMin</a> (available from that page).  For CSS, I use a simple 10-minute hack, which does the following:</p><ul><li>Gets rid of comments</li><li>Gets rid of whitespace, except between identifiers (this is way too aggressive for arbitrary CSS, but happens to work fine on my files &#8212; after some tweaks, at least)</li><li>Replaces color names with hex codes and replaces 6-digit hex codes with 3-digit codes where possible.</li><li>Combines my files with Yahoo&#8217;s CSS files (see above).</li></ul><p>(if anyone is aware of a more robust Python solution for CSS minification, let me know.)</p><p>The result is a (currently) 7800-byte large CSS file (2200 when gzipped), and a 960-byte JavaScript file (480 when gzipped).</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"></div></div></div></div><div class="yui-b"><div id='menu'><ul><li><b><a href="/" title="Go to effbot.org.">::: effbot.org</a></b></li><li><b><a href="." title="Go to zone index page.">::: zone :::</a></b></li></ul><ul><li><b>::: contents</b></li></ul><ul><li><ul><li><a href="#design">Design</a></li><li><ul><li><a href="#aiming-for-typographic-perfection">Aiming for Typographic Perfection</a></li></ul></li><li><a href="#performance">Performance</a></li><li><a href="#some-performance-observations">Some Performance Observations</a></li><li><ul><li><a href="#middleware-order">Middleware Order</a></li><li><a href="#accessing-large-database-records">Accessing Large Database Records</a></li><li><a href="#django-caching">Django Caching</a></li><li><a href="#media-caching">Media Caching</a></li><li><a href="#server-crowding">Server Crowding</a></li><li><a href="#resource-minification">Resource Minification</a></li></ul></li></ul></li></ul></div></div></div><div id="ft"><p><a href="http://www.djangoproject.com/"><img src="/media/img/djangosite80x15.gif" border="0" alt="A Django site." title="A Django site." style="vertical-align: bottom;" width="80" height="15" ></a>
rendered by a <a href="http://www.djangoproject.com/">django</a> application.  hosted by <a href="http://www.webfaction.com/shared_hosting?affiliate=slab">webfaction</a>.</p></div></div><script src="/media/js/effbot-min.js" type="text/javascript"></script></body></html>
