<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="shortcut icon" href="/media/img/effbot.ico"><link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"><link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"><title>Lexical&nbsp;analysis</title><script type="text/javascript">effbot_page_id=1358;</script></head><body><div id="doc2" class="yui-t2"><div id="hd"><!-- header --></div><!-- hd --><div id="bd"><!-- body --><p class="note" style="text-align: center"><strong>

We're back after a server migration that caused effbot.org to fall
over a bit harder than expected.  Expect some glitches.

</strong></p><div id="yui-main"><div class="yui-b"><div class="content"><div class="yui-g"><h1 class="maintitle">Lexical&nbsp;analysis</h1></div><!-- yui-g --><body><p>A Python program is read by a <em>parser</em>.  Input to the parser is a
stream of <em>tokens</em>, generated by the <em>lexical analyzer</em>.  This chapter
describes how the lexical analyzer breaks a file into tokens.</p>

<p>Python uses the 7-bit ASCII character set for program text.</p>

<p>New in version 2.3: An encoding declaration can be used to indicate
that string literals and comments use an encoding different from
ASCII. For compatibility with older versions, Python only warns if it
finds 8-bit characters; those warnings should be corrected by either
declaring an explicit encoding, or using escape sequences if those
bytes are binary data, instead of characters.</p>

<p>The run-time character set depends on the I/O devices connected to the
program but is generally a superset of ASCII.</p>

<p><strong>Future compatibility note:</strong> It may be tempting to assume that the
character set for 8-bit characters is ISO Latin-1 (an ASCII superset
that covers most western languages that use the Latin alphabet), but
it is possible that in the future Unicode text editors will become
common. These generally use the UTF-8 encoding, which is also an ASCII
superset, but with very different use for the characters with ordinals
128-255. While there is no consensus on this subject yet, it is unwise
to assume either Latin-1 or UTF-8, even though the current
implementation appears to favor Latin-1. This applies both to the
source character set and the run-time character set.</p>

<h2 id="line-structure">Line structure</h2>

<p>A Python program is divided into a number of <em>logical lines</em>.</p>

<h2 id="logical-lines">Logical lines</h2>

<p>The end of a logical line is represented by the token
NEWLINE. Statements cannot cross logical line boundaries except where
NEWLINE is allowed by the syntax (e.g., between statements in compound
statements). A logical line is constructed from one or more <em>physical
lines</em> by following the explicit or implicit <em>line joining</em> rules.</p>

<h2 id="physical-lines">Physical lines</h2>

<p>A physical line is a sequence of characters terminated by an
end-of-line sequence. In source files, any of the standard platform
line termination sequences can be used &#8212; the Unix form using ASCII LF
(linefeed), the Windows form using the ASCII sequence CR LF (return
followed by linefeed), or the Macintosh form using the ASCII CR
(return) character. All of these forms can be used equally, regardless
of platform.</p>

<p>When embedding Python, source code strings should be passed to Python
APIs using the standard C conventions for newline characters (the <code>\n</code>
character, representing ASCII LF, is the line terminator).</p>

<h2 id="comments">Comments</h2>

<p>A comment starts with a hash character (<code>#</code>) that is not part of a
string literal, and ends at the end of the physical line. A comment
signifies the end of the logical line unless the implicit line joining
rules are invoked. Comments are ignored by the syntax; they are not
tokens.</p>

<h2 id="encoding-declarations">Encoding declarations</h2>

<p>If a comment in the first or second line of the Python script matches
the regular expression coding[=:]\s*([-\w.]+), this comment is
processed as an encoding declaration; the first group of this
expression names the encoding of the source code file. The recommended
forms of this expression are</p>

<pre class="python"><code># -*- coding: &lt;encoding-name&gt; -*-
</code></pre>

<p>which is recognized also by GNU Emacs, and</p>

<pre class="python"><code># vim:fileencoding=&lt;encoding-name&gt;
</code></pre>

<p>which is recognized by VIM.  In addition, if the first bytes of the
file are the UTF-8 byte-order mark (<code>'\xef\xbb\xbf'</code>), the declared
file encoding is UTF-8 (this is supported, among others, by
Microsoft&#8217;s <strong>notepad</strong>).</p>

<p>If an encoding is declared, the encoding name must be recognized by
Python. The encoding is used for all lexical analysis, in particular
to find the end of a string, and to interpret the contents of Unicode
literals. String literals are converted to Unicode for syntactical
analysis, then converted back to their original encoding before
interpretation starts. The encoding declaration must appear on a line
of its own.</p>

<h2 id="explicit-line-joining">Explicit line joining</h2>

<p>Two or more physical lines may be joined into logical lines using
backslash characters (<code>\</code>), as follows: when a physical line ends in a
backslash that is not part of a string literal or comment, it is
joined with the following forming a single logical line, deleting the
backslash and the following end-of-line character. For example:</p>

<pre><code>if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \
   and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \
   and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60:   # Looks like a valid date
        return 1
</code></pre>

<p>A line ending in a backslash cannot carry a comment. A backslash does
not continue a comment. A backslash does not continue a token except
for string literals (i.e., tokens other than string literals cannot be
split across physical lines using a backslash). A backslash is illegal
elsewhere on a line outside a string literal.</p>

<h2 id="implicit-line-joining">Implicit line joining</h2>

<p>Expressions in parentheses, square brackets or curly braces can be
split over more than one physical line without using backslashes. For
example:</p>

<pre class="python"><code>month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
</code></pre>

<p>Implicitly continued lines can carry comments. The indentation of the
continuation lines is not important. Blank continuation lines are
allowed. There is no NEWLINE token between implicit continuation
lines. Implicitly continued lines can also occur within triple-quoted
strings (see below); in that case they cannot carry comments.</p>

<h2 id="blank-lines">Blank lines</h2>

<p>A logical line that contains only spaces, tabs, formfeeds and possibly
a comment, is ignored (i.e., no NEWLINE token is generated). During
interactive input of statements, handling of a blank line may differ
depending on the implementation of the read-eval-print loop. In the
standard implementation, an entirely blank logical line (i.e. one
containing not even whitespace or a comment) terminates a multi-line
statement.</p>

<h2 id="indentation">Indentation</h2>

<p>Leading whitespace (spaces and tabs) at the beginning of a logical
line is used to compute the indentation level of the line, which in
turn is used to determine the grouping of statements.</p>

<p>First, tabs are replaced (from left to right) by one to eight spaces
such that the total number of characters up to and including the
replacement is a multiple of eight (this is intended to be the same
rule as used by Unix). The total number of spaces preceding the first
non-blank character then determines the line&#8217;s indentation.
Indentation cannot be split over multiple physical lines using
backslashes; the whitespace up to the first backslash determines the
indentation.</p>

<p><strong>Cross-platform compatibility note:</strong> because of the nature of text
editors on non-UNIX platforms, it is unwise to use a mixture of spaces
and tabs for the indentation in a single source file. It should also
be noted that different platforms may explicitly limit the maximum
indentation level.</p>

<p>A formfeed character may be present at the start of the line; it will
be ignored for the indentation calculations above. Formfeed characters
occurring elsewhere in the leading whitespace have an undefined effect
(for instance, they may reset the space count to zero).</p>

<p>The indentation levels of consecutive lines are used to generate
INDENT and DEDENT tokens, using a stack, as follows.</p>

<p>Before the first line of the file is read, a single zero is pushed on
the stack; this will never be popped off again. The numbers pushed on
the stack will always be strictly increasing from bottom to top. At
the beginning of each logical line, the line&#8217;s indentation level is
compared to the top of the stack. If it is equal, nothing happens. If
it is larger, it is pushed on the stack, and one INDENT token is
generated. If it is smaller, it <em>must</em> be one of the numbers
occurring on the stack; all numbers on the stack that are larger are
popped off, and for each number popped off a DEDENT token is
generated. At the end of the file, a DEDENT token is generated for
each number remaining on the stack that is larger than zero.</p>

<p>Here is an example of a correctly (though confusingly) indented piece
of Python code:</p>

<pre class="python"><code>def perm(l):
        # Compute the list of all permutations of l
    if len(l) &lt;= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r
</code></pre>

<p>The following example shows various indentation errors:</p>

<pre><code> def perm(l):                       # error: first line indented
for i in range(len(l)):             # error: not indented
    s = l[:i] + l[i+1:]
        p = perm(l[:i] + l[i+1:])   # error: unexpected indent
        for x in p:
                r.append(l[i:i+1] + x)
            return r                # error: inconsistent dedent
</code></pre>

<p>(Actually, the first three errors are detected by the parser; only the
last error is found by the lexical analyzer &#8212; the indentation of
<code>return r</code> does not match a level popped off the stack.)</p>

<h2 id="whitespace-between-tokens">Whitespace between tokens</h2>

<p>Except at the beginning of a logical line or in string literals, the
whitespace characters space, tab and formfeed can be used
interchangeably to separate tokens. Whitespace is needed between two
tokens only if their concatenation could otherwise be interpreted as a
different token (e.g., ab is one token, but a b is two tokens).</p></body><div class="yui-g"></div><!-- yui-g --></div><!-- content --></div><!-- yui-b --></div><!-- yui-main --><div class="yui-b"><div id='menu'></div><!-- menu --></div><!-- yui-b --></div><!-- bd --><div id="ft"><!-- footer --></div><!-- ft --></div><!-- doc --><script src="/media/js/effbot-min.js" type="text/javascript"></script></body></html>
