<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"> <link rel="shortcut icon" href="/media/img/effbot.ico"> <link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"> <link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"> <title>ElementTree: Working with Namespaces and Qualified&nbsp;Names</title> <script type="text/javascript">effbot_page_id=83;</script> </head> <body> <div id="doc2" class="yui-t2"> <div id="hd"> <!-- header --> <!--
<p style='color: #8f8f8f; background: #fff5bf; padding: 5px 10px;'> <b>2008-07-15:</b> Selected articles

now have experimental "comment" links in the left column and at the bottom.
You're welcome to use them for commenting and voting on articles.
For a bit more on this, see <a
href="http://effbot.slinkset.com/links/Welcome_to_discuss_effbot_org">this
page</a>. /F
</p>
--> </div> <!-- hd --> <div id="bd"> <!-- body --> <div id="yui-main"> <div class="yui-b"> <div class="content"><div class="yui-g"> <h1 class="maintitle">ElementTree: Working with Namespaces and Qualified&nbsp;Names</h1> </div> <!-- yui-g --><div class="yui-ge"><div class="yui-u first"><p class="info">Fredrik Lundh | August 2007</p><p>The XML Namespace specification adds <em>qualified names</em> to XML.  A qualified name is a tag or attribute name that is associated with a given namespace.  A namespace usually represents some kind of application domain, such as hypertext, graphics, resource descriptions, or type information.  The Namespace specification allows a single XML document to contain tags and attributes from any number of namespaces, without conflicts.</p><p>Conceptually, a qualified name is represented as a (<em>namespace URI</em>, <em>local part</em>) pair.  The local part is the actual tag or attribute name, while the URI identifies the namespace that the name belongs to.  This is similar to variables and modules in Python; the local part is the variable name, while the namespace is the module that the variable lives in.  The same local name may appear in multiple namespaces in the same document, possibly with radically different semantics:</p><pre class="python">(<span class="pystring">"http://www.w3.org/1999/xhtml"</span>, <span class="pystring">"a"</span>)
(<span class="pystring">"http://effbot.org/namespace/letters"</span>, <span class="pystring">"a"</span>)
(<span class="pystring">"http://schema.irs.gov/income-tax-form/field"</span>, <span class="pystring">"a"</span>)</pre><p>Note that the use of an HTTP URI for the namespace makes it easy to allocate new namespaces without having to use a central registry.  It also offers a convenient location for keeping information about the namespace, but that&#8217;s not required by the specification.  Some applications use custom URI schemas instead; for example, the WebDAV protocol uses the &#8220;DAV:&#8221; scheme, mostly for historical reasons.  From a data modelling perspective, the namespace URI should be treated as an opaque string of characters.</p><h2 id="xml-serialization">XML Serialization&#160;<a class="nav" href="#xml-serialization" title="bookmark!">#</a></h2><p>The XML Namespace specification uses a simple encoding scheme to store qualified names in XML in an efficient way.  The scheme is designed to be compatible with tools that don&#8217;t use XML namespaces, and is also reasonably easy to use for human authors.</p><p>To understand the encoding model, let&#8217;s look at a simple XHTML anchor element.  In standard HTML, a single anchor instance can look something like this:</p><pre><code>&lt;a href="uri"&gt;link text&lt;/a&gt;
</code></pre><p>In XHTML, the &#8220;a&#8221; element lives in the &#8220;http://www.w3.org/1999/xhtml&#8221; namespace, so the full name we need to encode in the file consists of the pair <code>("http://www.w3.org/1999/xhtml", "a")</code>.</p><p>We could simply store the namespace URI together with the local part in the serialized XML document, using some suitable separator to tell the pieces apart:</p><pre><code>&lt;http://www.w3.org/1999/xhtml#a href="uri"&gt;
link text&lt;/http://www.w3.org/1999/xhtml#a&gt;
</code></pre><p>This is of course rather unwieldy, and is very verbose; we&#8217;ll end up repeating the URI over and over again.  To save space, we could use some kind of &#8220;macro facility&#8221;, and define shorter aliases for the namespaces we&#8217;re using in the document.  Here&#8217;s a C-like approach:</p><pre><code>&lt;#define html "http://www.w3.org/1999/xhtml"&gt;

&lt;html:a href="uri"&gt;link text&lt;/html:a&gt;
</code></pre><p>A parser that understands this (hypothetical) format would first parse the &lt;#define&gt; sections, and then use the aliases defined there to expand the element and attribute names in the rest of the document.</p><p>The approach used by XML Namespaces is similar, but instead of separate syntax for namespace declarations, it uses special <strong>xmlns</strong> attributes embedded in the XML document itself.  The line</p><pre><code>&lt;#define html "http://www.w3.org/1999/xhtml"&gt;
</code></pre><p>is turned into an attribute</p><pre><code>xmlns:html="http://www.w3.org/1999/xhtml"
</code></pre><p>where the <strong>html</strong> part is known as a <em>prefix</em>.  The <strong>xmlns</strong> attribute is then added to the element:</p><pre><code>&lt;html:a href="uri"
xmlns:html="http://www.w3.org/1999/xhtml"&gt;
link text&lt;/html:a&gt;
</code></pre><p>This tells a namespace-aware parser that the <strong>a</strong> element belongs to the &#8220;http://www.w3.org/1999/xhtml&#8221; namespace, and the element&#8217;s qualified name is thus set to the pair <code>("http://www.w3.org/1999/xhtml", "a")</code>.  The <strong>xmlns</strong> attribute and the prefix are discarded by the parser; they are part of the serialization, not the data model.</p><p>The declarations apply not only to the element they appear in, but also to all child elements.  This lets you add new elements to the document, without having to repeat the <strong>xmlns</strong> attribute for each new element.  In the following example, the anchor is put inside an XHTML paragraph element:</p><pre><code>&lt;html:p xmlns:html="http://www.w3.org/1999/xhtml"&gt;
This is a paragraph, with some &lt;html:a href="uri"&gt;
link text&lt;/html:a&gt;.&lt;/html:p&gt;
</code></pre><p>To keep documents small and tidy, the namespace declarations are often added to the root element (e.g. the <strong>html</strong> element in an XHTML document).</p><p>Note that declarations may be overridden by <strong>xmlns</strong> attributes in child elements, and the same prefix may refer to different namespaces in different parts of the document.</p><h2 id="element-tree-representation">Element Tree Representation&#160;<a class="nav" href="#element-tree-representation" title="bookmark!">#</a></h2><p>In an Element tree, qualified names are stored as <em>universal names</em> in Clark&#8217;s notation, which combines the URI and the local part into a single string, g