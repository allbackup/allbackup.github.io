<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>threading</title>
<style type='text/css'>body { font: 100% Georgia, Times, serif; } a.nav:link, a.nav:visited { color: #88f; } .nav { color: #88f; } a.nav:hover { color: blue; } .mark { color: #048444; }</style>
<meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
</head><body>
<table style='font-size: 8pt; background: #efe; padding: 5px; border: 1px solid #084; margin: 0px 0px 20px 0px;' border='0' cellspacing='0' cellpadding='0' width='100%'><tr><td align='left'>
an alternative python reference (<a href='/zone/pythondoc-lib.htm'>in progress</a>)
</td><td align='right'>
<a href='http://docs.python.org/lib/module-threading.html'>original</a> :::
<a href='threading.txt'>source</a> :::
<a href='/lib/index.html'>index</a>
</td></tr></table><table style='font-size: 8pt; background: white; padding: 5px; border: 1px solid #084; margin: 0px 0px 20px 0px;' border='0' cellspacing='0' cellpadding='0' width='100%%'><tr><td align='left'>
<b>note:</b> this page has been automatically converted from python.org
sources, and may contain errors and omissions introduced by the conversion
process.
</td></tr></table><div class="body"><div class="module">
<h1>threading&#8212;Higher-level threading interface</h1>

<div class="toc"><dl><dt>On this page:</dt><dd><a href="#lock-objects">Lock Objects</a></dd><dd><a href="#rlock-objects">RLock Objects</a></dd><dd><a href="#condition-objects">Condition Objects</a></dd><dd><a href="#semaphore-objects">Semaphore Objects</a></dd><dd><a href="#event-objects">Event Objects</a></dd><dd><a href="#thread-objects">Thread Objects</a></dd><dd><a href="#timer-objects">Timer Objects</a></dd></dl></div><p>This module constructs higher-level threading interfaces on top
of the lower level <code>thread</code>
module.</p>

<p>The <code>
dummy_threading</code> module is provided for situations where <code>threading</code> cannot be used
because <code>thread</code> is
missing.</p>

<p>This module defines the following functions and objects:</p>
</div>
<dl><dt class="function" id="activeCount"><b>activeCount()</b> <tt class="nav"><a class="nav" href="threading.activeCount" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Return the number of currently active <a class="link" href="#Thread"><code>Thread</code></a> objects. The returned count is equal
to the length of the list returned by <a class="link" href="#enumerate"><code>enumerate</code></a>. A function that returns the
number of currently active threads.</p>
</dd>
<dt class="function" id="Condition"><b>Condition()</b> <tt class="nav"><a class="nav" href="threading.Condition" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new condition variable object.
A condition variable allows one or more threads to wait until they
are notified by another thread.</p>
</dd>
<dt class="function" id="currentThread"><b>currentThread()</b> <tt class="nav"><a class="nav" href="threading.currentThread" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Return the current <a class="link" href="#Thread"><code>Thread</code></a>
object, corresponding to the caller's thread of control. If the
caller's thread of control was not created through the <code>threading</code> module, a dummy
thread object with limited functionality is returned.</p>
</dd>
<dt class="function" id="enumerate"><b>enumerate()</b> <tt class="nav"><a class="nav" href="threading.enumerate" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Return a list of all currently active <a class="link" href="#Thread"><code>Thread</code></a> objects. The list includes daemonic
threads, dummy thread objects created by <a class="link" href="#currentThread"><code>currentThread</code></a>, and the main thread.
It excludes terminated threads and threads that have not yet been
started.</p>
</dd>
<dt class="function" id="Event"><b>Event()</b> <tt class="nav"><a class="nav" href="threading.Event" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new event object. An event
manages a flag that can be set to true with the <code>set</code> method and reset to false with the <code>clear</code> method. The <code>wait</code> method blocks until the flag
is true.</p>
</dd>
<dt class="class" id="local"><b>class local</b> <tt class="nav"><a class="nav" href="threading.local" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>A class that represents thread-local data. Thread-local data are
data whose values are thread specific. To manage thread-local data,
just create an instance of <a class="link" href="#local"><code>
local</code></a> (or a subclass) and store attributes on it:</p>

<pre>
mydata = threading.local()
mydata.x = 1
</pre>

<p>The instance's values will be different for separate
threads.</p>

<p>For more details and extensive examples, see the documentation
string of the <code>
_threading_local</code> module.</p>

<blockquote><span class="mark">@since</span> New in version
2.4.<br />
</blockquote>
</dd>
<dt class="function" id="Lock"><b>Lock()</b> <tt class="nav"><a class="nav" href="threading.Lock" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new primitive lock object.
Once a thread has acquired it, subsequent attempts to acquire it
block, until it is released; any thread may release it.</p>
</dd>
<dt class="function" id="RLock"><b>RLock()</b> <tt class="nav"><a class="nav" href="threading.RLock" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new reentrant lock object. A
reentrant lock must be released by the thread that acquired it.
Once a thread has acquired a reentrant lock, the same thread may
acquire it again without blocking; the thread must release it once
for each time it has acquired it.</p>
</dd>
<dt class="function" id="Semaphore"><b>Semaphore([value])</b> <tt class="nav"><a class="nav" href="threading.Semaphore" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new semaphore object. A
semaphore manages a counter representing the number of <code>release</code> calls minus the number
of <code>acquire</code> calls, plus an
initial value. The <code>acquire</code>
method blocks if necessary until it can return without making the
counter negative. If not given, <var>value</var> defaults to 1.</p>
</dd>
<dt class="function" id="BoundedSemaphore"><b>BoundedSemaphore([value])</b> <tt class="nav"><a class="nav" href="threading.BoundedSemaphore" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>A factory function that returns a new bounded semaphore object.
A bounded semaphore checks to make sure its current value doesn't
exceed its initial value. If it does, <code>exceptions.ValueError</code> is
raised. In most situations semaphores are used to guard resources
with limited capacity. If the semaphore is released too many times
it's a sign of a bug. If not given, <var>value</var> defaults to
1.</p>
</dd>
<dt class="class" id="Thread"><b>class Thread</b> <tt class="nav"><a class="nav" href="threading.Thread" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>A class that represents a thread of control. This class can be
safely subclassed in a limited fashion.</p>
</dd>
<dt class="class" id="Timer"><b>class Timer</b> <tt class="nav"><a class="nav" href="threading.Timer" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>A thread that executes a function after a specified interval has
passed.</p>
</dd>
<dt class="function" id="settrace"><b>settrace(func)</b> <tt class="nav"><a class="nav" href="threading.settrace" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Set a trace function for all threads started from the <code>threading</code> module. The <var>
func</var> will be passed to <code>sys.settrace</code> for each thread, before
its <code>run</code> method is called.</p>

<blockquote><span class="mark">@since</span> New in version
2.3.<br />
</blockquote>
</dd>
<dt class="function" id="setprofile"><b>setprofile(func)</b> <tt class="nav"><a class="nav" href="threading.setprofile" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Set a profile function for all threads started from the <code>threading</code> module. The <var>
func</var> will be passed to <code>sys.setprofile</code> for each thread,
before its <code>run</code> method is
called.</p>

<blockquote><span class="mark">@since</span> New in version
2.3.<br />
</blockquote>
</dd>
</dl><div class="text">
<p>Detailed interfaces for the objects are documented below.</p>

<p>The design of this module is loosely based on Java's threading
model. However, where Java makes locks and condition variables
basic behavior of every object, they are separate objects in
Python. Python's <a class="link" href="#Thread"><code>Thread</code></a>
class supports a subset of the behavior of Java's Thread class;
currently, there are no priorities, no thread groups, and threads
cannot be destroyed, stopped, suspended, resumed, or interrupted.
The static methods of Java's Thread class, when implemented, are
mapped to module-level functions.</p>

<p>All of the methods described below are executed atomically.</p>

<h2 id="lock-objects">Lock Objects <a class="nav" href="#lock-objects">#</a></h2>

<p>A primitive lock is a synchronization primitive that is not
owned by a particular thread when locked. In Python, it is
currently the lowest level synchronization primitive available,
implemented directly by the <code>
thread</code> extension module.</p>

<p>A primitive lock is in one of two states, &#8220;locked&#8221;
or &#8220;unlocked&#8221;. It is created in the unlocked state. It
has two basic methods, <code>
acquire</code> and <code>release</code>.
When the state is unlocked, <code>
acquire</code> changes the state to locked and returns immediately.
When the state is locked, <code>
acquire</code> blocks until a call to <code>release</code> in another thread changes it to
unlocked, then the <code>acquire</code>
call resets it to locked and returns. The <code>release</code> method should only be called in the
locked state; it changes the state to unlocked and returns
immediately. When more than one thread is blocked in <code>acquire</code> waiting for the state
to turn to unlocked, only one thread proceeds when a <code>release</code> call resets the state
to unlocked; which one of the waiting threads proceeds is not
defined, and may vary across implementations.</p>

<p>All methods are executed atomically.</p>
</div>
<dl><dt class="method" id="Lock.acquire"><b>acquire([blocking = 1])</b> <tt class="nav"><a class="nav" href="threading.Lock.acquire" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Acquire a lock, blocking or non-blocking.</p>

<p>When invoked without arguments, block until the lock is
unlocked, then set it to locked, and return true.</p>

<p>When invoked with the <var>blocking</var> argument set to true,
do the same thing as when called without arguments, and return
true.</p>

<p>When invoked with the <var>blocking</var> argument set to false,
do not block. If a call without an argument would block, return
false immediately; otherwise, do the same thing as when called
without arguments, and return true.</p>
</dd>
<dt class="method" id="Lock.release"><b>release()</b> <tt class="nav"><a class="nav" href="threading.Lock.release" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Release a lock.</p>

<p>When the lock is locked, reset it to unlocked, and return. If
any other threads are blocked waiting for the lock to become
unlocked, allow exactly one of them to proceed.</p>

<p>Do not call this method when the lock is unlocked.</p>

<p>There is no return value.</p>
</dd>
</dl><div class="text">
<h2 id="rlock-objects">RLock Objects <a class="nav" href="#rlock-objects">#</a></h2>

<p>A reentrant lock is a synchronization primitive that may be
acquired multiple times by the same thread. Internally, it uses the
concepts of &#8220;owning thread&#8221; and &#8220;recursion
level&#8221; in addition to the locked/unlocked state used by
primitive locks. In the locked state, some thread owns the lock; in
the unlocked state, no thread owns it.</p>

<p>To lock the lock, a thread calls its <code>acquire</code> method; this returns once the
thread owns the lock. To unlock the lock, a thread calls its <code>release</code> method. <code>acquire</code>/<code>release</code> call pairs may be nested; only the
final <code>release</code> (the <code>release</code> of the outermost pair)
resets the lock to unlocked and allows another thread blocked in <code>acquire</code> to proceed.</p>
</div>
<dl><dt class="method" id="RLock.acquire"><b>acquire([blocking = 1])</b> <tt class="nav"><a class="nav" href="threading.RLock.acquire" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Acquire a lock, blocking or non-blocking.</p>

<p>When invoked without arguments: if this thread already owns the
lock, increment the recursion level by one, and return immediately.
Otherwise, if another thread owns the lock, block until the lock is
unlocked. Once the lock is unlocked (not owned by any thread), then
grab ownership, set the recursion level to one, and return. If more
than one thread is blocked waiting until the lock is unlocked, only
one at a time will be able to grab ownership of the lock. There is
no return value in this case.</p>

<p>When invoked with the <var>blocking</var> argument set to true,
do the same thing as when called without arguments, and return
true.</p>

<p>When invoked with the <var>blocking</var> argument set to false,
do not block. If a call without an argument would block, return
false immediately; otherwise, do the same thing as when called
without arguments, and return true.</p>
</dd>
<dt class="method" id="RLock.release"><b>release()</b> <tt class="nav"><a class="nav" href="threading.RLock.release" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Release a lock, decrementing the recursion level. If after the
decrement it is zero, reset the lock to unlocked (not owned by any
thread), and if any other threads are blocked waiting for the lock
to become unlocked, allow exactly one of them to proceed. If after
the decrement the recursion level is still nonzero, the lock
remains locked and owned by the calling thread.</p>

<p>Only call this method when the calling thread owns the lock. Do
not call this method when the lock is unlocked.</p>

<p>There is no return value.</p>
</dd>
</dl><div class="text">
<h2 id="condition-objects">Condition Objects <a class="nav" href="#condition-objects">#</a></h2>

<p>A condition variable is always associated with some kind of
lock; this can be passed in or one will be created by default.
(Passing one in is useful when several condition variables must
share the same lock.)</p>

<p>A condition variable has <code>
acquire</code> and <code>release</code>
methods that call the corresponding methods of the associated lock.
It also has a <code>wait</code> method, and
<code>notify</code> and <code>notifyAll</code> methods. These three must only
be called when the calling thread has acquired the lock.</p>

<p>The <code>wait</code> method releases
the lock, and then blocks until it is awakened by a <code>notify</code> or <code>notifyAll</code> call for the same condition
variable in another thread. Once awakened, it re-acquires the lock
and returns. It is also possible to specify a timeout.</p>

<p>The <code>notify</code> method wakes
up one of the threads waiting for the condition variable, if any
are waiting. The <code>
notifyAll</code> method wakes up all threads waiting for the condition
variable.</p>

<p>Note: the <code>notify</code> and <code>notifyAll</code> methods don't
release the lock; this means that the thread or threads awakened
will not return from their <code>
wait</code> call immediately, but only when the thread that called <code>notify</code> or <code>notifyAll</code> finally relinquishes ownership
of the lock.</p>

<p>Tip: the typical programming style using condition variables
uses the lock to synchronize access to some shared state; threads
that are interested in a particular change of state call <code>wait</code> repeatedly until they see
the desired state, while threads that modify the state call <code>notify</code> or <code>notifyAll</code> when they change the state in
such a way that it could possibly be a desired state for one of the
waiters. For example, the following code is a generic
producer-consumer situation with unlimited buffer capacity:</p>

<pre>
# Consume one item
cv.acquire()
while not an_item_is_available():
    cv.wait()
get_an_available_item()
cv.release()

# Produce one item
cv.acquire()
make_an_item_available()
cv.notify()
cv.release()
</pre>

<p>To choose between <code>notify</code>
and <code>notifyAll</code>, consider
whether one state change can be interesting for only one or several
waiting threads. E.g. in a typical producer-consumer situation,
adding one item to the buffer only needs to wake up one consumer
thread.</p>
</div>
<dl><dt class="class"><b>class Condition([lock])</b> <tt class="nav"><a class="nav" href="threading.Condition" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>If the <var>lock</var> argument is given and not <code>
None</code>, it must be a <a class="link" href="#Lock"><code>Lock</code></a>
or <a class="link" href="#RLock"><code>RLock</code></a> object, and it is
used as the underlying lock. Otherwise, a new <a class="link" href="#RLock"><code>RLock</code></a> object is created and used as the
underlying lock.</p>
</dd>
<dt class="method" id="Condition.acquire"><b>acquire(*args)</b> <tt class="nav"><a class="nav" href="threading.Condition.acquire" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Acquire the underlying lock. This method calls the corresponding
method on the underlying lock; the return value is whatever that
method returns.</p>
</dd>
<dt class="method" id="Condition.release"><b>release()</b> <tt class="nav"><a class="nav" href="threading.Condition.release" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Release the underlying lock. This method calls the corresponding
method on the underlying lock; there is no return value.</p>
</dd>
<dt class="method" id="Condition.wait"><b>wait([timeout])</b> <tt class="nav"><a class="nav" href="threading.Condition.wait" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Wait until notified or until a timeout occurs. This must only be
called when the calling thread has acquired the lock.</p>

<p>This method releases the underlying lock, and then blocks until
it is awakened by a <code>notify</code>
or <code>notifyAll</code> call for the
same condition variable in another thread, or until the optional
timeout occurs. Once awakened or timed out, it re-acquires the lock
and returns.</p>

<p>When the <var>timeout</var> argument is present and not <code>
None</code>, it should be a floating point number specifying a
timeout for the operation in seconds (or fractions thereof).</p>

<p>When the underlying lock is an <a class="link" href="#RLock"><code>RLock</code></a>, it is not released using its <code>release</code> method, since this may
not actually unlock the lock when it was acquired multiple times
recursively. Instead, an internal interface of the <a class="link" href="#RLock"><code>RLock</code></a> class is used, which really unlocks it
even when it has been recursively acquired several times. Another
internal interface is then used to restore the recursion level when
the lock is reacquired.</p>
</dd>
<dt class="method" id="Condition.notify"><b>notify()</b> <tt class="nav"><a class="nav" href="threading.Condition.notify" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Wake up a thread waiting on this condition, if any. This must
only be called when the calling thread has acquired the lock.</p>

<p>This method wakes up one of the threads waiting for the
condition variable, if any are waiting; it is a no-op if no threads
are waiting.</p>

<p>The current implementation wakes up exactly one thread, if any
are waiting. However, it's not safe to rely on this behavior. A
future, optimized implementation may occasionally wake up more than
one thread.</p>

<p>Note: the awakened thread does not actually return from its <code>wait</code> call until it can reacquire
the lock. Since <code>notify</code> does
not release the lock, its caller should.</p>
</dd>
<dt class="method" id="Condition.notifyAll"><b>notifyAll()</b> <tt class="nav"><a class="nav" href="threading.Condition.notifyAll" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Wake up all threads waiting on this condition. This method acts
like <code>notify</code>, but wakes up
all waiting threads instead of one.</p>
</dd>
</dl><div class="text">
<h2 id="semaphore-objects">Semaphore Objects <a class="nav" href="#semaphore-objects">#</a></h2>

<p>This is one of the oldest synchronization primitives in the
history of computer science, invented by the early Dutch computer
scientist Edsger W. Dijkstra (he used <code>P</code> and <code>V</code> instead
of <code>acquire</code> and <code>release</code>).</p>

<p>A semaphore manages an internal counter which is decremented by
each <code>acquire</code> call and
incremented by each <code>release</code>
call. The counter can never go below zero; when <code>acquire</code> finds that it is zero, it blocks,
waiting until some other thread calls <code>release</code>.</p>
</div>
<dl><dt class="class"><b>class Semaphore([value])</b> <tt class="nav"><a class="nav" href="threading.Semaphore" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>The optional argument gives the initial value for the internal
counter; it defaults to <code>1</code>.</p>
</dd>
<dt class="method" id="Semaphore.acquire"><b>acquire([blocking])</b> <tt class="nav"><a class="nav" href="threading.Semaphore.acquire" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Acquire a semaphore.</p>

<p>When invoked without arguments: if the internal counter is
larger than zero on entry, decrement it by one and return
immediately. If it is zero on entry, block, waiting until some
other thread has called <code>
release</code> to make it larger than zero. This is done with proper
interlocking so that if multiple <code>acquire</code> calls are blocked, <code>release</code> will wake exactly one of them up.
The implementation may pick one at random, so the order in which
blocked threads are awakened should not be relied on. There is no
return value in this case.</p>

<p>When invoked with <var>blocking</var> set to true, do the same
thing as when called without arguments, and return true.</p>

<p>When invoked with <var>blocking</var> set to false, do not
block. If a call without an argument would block, return false
immediately; otherwise, do the same thing as when called without
arguments, and return true.</p>
</dd>
<dt class="method" id="Semaphore.release"><b>release()</b> <tt class="nav"><a class="nav" href="threading.Semaphore.release" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Release a semaphore, incrementing the internal counter by one.
When it was zero on entry and another thread is waiting for it to
become larger than zero again, wake up that thread.</p>
</dd>
</dl><div class="error">
<h3>Semaphore Example</h3>

<p>Semaphores are often used to guard resources with limited
capacity, for example, a database server. In any situation where
the size of the resource size is fixed, you should use a bounded
semaphore. Before spawning any worker threads, your main thread
would initialize the semaphore:</p>

<pre>
maxconnections = 5
...
pool_sema = BoundedSemaphore(value=maxconnections)
</pre>

<p>Once spawned, worker threads call the semaphore's acquire and
release methods when they need to connect to the server:</p>

<pre>
pool_sema.acquire()
conn = connectdb()
... use connection ...
conn.close()
pool_sema.release()
</pre>

<p>The use of a bounded semaphore reduces the chance that a
programming error which causes the semaphore to be released more
than it's acquired will go undetected.</p>

<h2 id="event-objects">Event Objects <a class="nav" href="#event-objects">#</a></h2>

<p>This is one of the simplest mechanisms for communication between
threads: one thread signals an event and other threads wait for
it.</p>

<p>An event object manages an internal flag that can be set to true
with the <code>set</code> method and reset
to false with the <code>clear</code>
method. The <code>wait</code> method blocks
until the flag is true.</p>
</div>
<dl><dt class="class"><b>class Event()</b> <tt class="nav"><a class="nav" href="threading.Event" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>The internal flag is initially false.</p>
</dd>
<dt class="method" id="Event.isSet"><b>isSet()</b> <tt class="nav"><a class="nav" href="threading.Event.isSet" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Return true if and only if the internal flag is true.</p>
</dd>
<dt class="method" id="Event.set"><b>set()</b> <tt class="nav"><a class="nav" href="threading.Event.set" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Set the internal flag to true. All threads waiting for it to
become true are awakened. Threads that call <code>wait</code> once the flag is true will not block at
all.</p>
</dd>
<dt class="method" id="Event.clear"><b>clear()</b> <tt class="nav"><a class="nav" href="threading.Event.clear" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Reset the internal flag to false. Subsequently, threads calling
<code>wait</code> will block until <code>set</code> is called to set the internal
flag to true again.</p>
</dd>
<dt class="method" id="Event.wait"><b>wait([timeout])</b> <tt class="nav"><a class="nav" href="threading.Event.wait" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Block until the internal flag is true. If the internal flag is
true on entry, return immediately. Otherwise, block until another
thread calls <code>set</code> to set the
flag to true, or until the optional timeout occurs.</p>

<p>When the timeout argument is present and not <code>None</code>, it should be a floating point number
specifying a timeout for the operation in seconds (or fractions
thereof).</p>
</dd>
</dl><div class="text">
<h2 id="thread-objects">Thread Objects <a class="nav" href="#thread-objects">#</a></h2>

<p>This class represents an activity that is run in a separate
thread of control. There are two ways to specify the activity: by
passing a callable object to the constructor, or by overriding the
<code>run</code> method in a subclass. No
other methods (except for the constructor) should be overridden in
a subclass. In other words, <em>only</em> override the <code>__init__</code> and <code>run</code> methods of this class.</p>

<p>Once a thread object is created, its activity must be started by
calling the thread's <code>start</code>
method. This invokes the <code>run</code>
method in a separate thread of control.</p>

<p>Once the thread's activity is started, the thread is considered
'alive' and 'active' (these concepts are almost, but not quite
exactly, the same; their definition is intentionally somewhat
vague). It stops being alive and active when its <code>run</code> method terminates - either normally, or by
raising an unhandled exception. The <code>isAlive</code> method tests whether the thread is
alive.</p>

<p>Other threads can call a thread's <code>join</code> method. This blocks the calling thread
until the thread whose <code>join</code>
method is called is terminated.</p>

<p>A thread has a name. The name can be passed to the constructor,
set with the <code>setName</code>
method, and retrieved with the <code>
getName</code> method.</p>

<p>A thread can be flagged as a &#8220;daemon thread&#8221;. The
significance of this flag is that the entire Python program exits
when only daemon threads are left. The initial value is inherited
from the creating thread. The flag can be set with the <code>setDaemon</code> method and
retrieved with the <code>
isDaemon</code> method.</p>

<p>There is a &#8220;main thread&#8221; object; this corresponds to
the initial thread of control in the Python program. It is not a
daemon thread.</p>

<p>There is the possibility that &#8220;dummy thread objects&#8221;
are created. These are thread objects corresponding to &#8220;alien
threads&#8221;. These are threads of control started outside the
threading module, such as directly from C code. Dummy thread
objects have limited functionality; they are always considered
alive, active, and daemonic, and cannot be <code>join</code>ed. They are never deleted, since it is
impossible to detect the termination of alien threads.</p>
</div>
<dl><dt class="class"><b>class Thread(group=None, target=None, name=None,
args=(), kwargs={})</b> <tt class="nav"><a class="nav" href="threading.Thread" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>This constructor should always be called with keyword arguments.
Arguments are:</p>

<p><var>group</var> should be <code>
None</code>; reserved for future extension when a <code>ThreadGroup</code> class is implemented.</p>

<p><var>target</var> is the callable object to be invoked by the <code>run</code> method. Defaults to <code>
None</code>, meaning nothing is called.</p>

<p><var>name</var> is the thread name. By default, a unique name is
constructed of the form &#8220;Thread-<var>N</var>&#8221; where
<var>N</var> is a small decimal number.</p>

<p><var>args</var> is the argument tuple for the target invocation.
Defaults to <code>()</code>.</p>

<p><var>kwargs</var> is a dictionary of keyword arguments for the
target invocation. Defaults to <code>{</code>}.</p>

<p>If the subclass overrides the constructor, it must make sure to
invoke the base class constructor (<code>Thread.__init__()</code>)
before doing anything else to the thread.</p>
</dd>
<dt class="method" id="Thread.start"><b>start()</b> <tt class="nav"><a class="nav" href="threading.Thread.start" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Start the thread's activity.</p>

<p>This must be called at most once per thread object. It arranges
for the object's <code>run</code> method to
be invoked in a separate thread of control.</p>
</dd>
<dt class="method" id="Thread.run"><b>run()</b> <tt class="nav"><a class="nav" href="threading.Thread.run" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Method representing the thread's activity.</p>

<p>You may override this method in a subclass. The standard <code>run</code> method invokes the callable
object passed to the object's constructor as the <var>target</var>
argument, if any, with sequential and keyword arguments taken from
the <var>args</var> and <var>kwargs</var> arguments,
respectively.</p>
</dd>
<dt class="method" id="Thread.join"><b>join([timeout])</b> <tt class="nav"><a class="nav" href="threading.Thread.join" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Wait until the thread terminates. This blocks the calling thread
until the thread whose <code>join</code>
method is called terminates - either normally or through an
unhandled exception - or until the optional timeout occurs.</p>

<p>When the <var>timeout</var> argument is present and not <code>
None</code>, it should be a floating point number specifying a
timeout for the operation in seconds (or fractions thereof). As <code>join</code> always returns <code>None</code>, you must call <code>isAlive</code> to decide whether a
timeout happened.</p>

<p>When the <var>timeout</var> argument is not present or <code>
None</code>, the operation will block until the thread
terminates.</p>

<p>A thread can be <code>join</code>ed many
times.</p>

<p>A thread cannot join itself because this would cause a
deadlock.</p>

<p>It is an error to attempt to <code>
join</code> a thread before it has been started.</p>
</dd>
<dt class="method" id="Thread.getName"><b>getName()</b> <tt class="nav"><a class="nav" href="threading.Thread.getName" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Return the thread's name.</p>
</dd>
<dt class="method" id="Thread.setName"><b>setName(name)</b> <tt class="nav"><a class="nav" href="threading.Thread.setName" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Set the thread's name.</p>

<p>The name is a string used for identification purposes only. It
has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p>
</dd>
<dt class="method" id="Thread.isAlive"><b>isAlive()</b> <tt class="nav"><a class="nav" href="threading.Thread.isAlive" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Return whether the thread is alive.</p>

<p>Roughly, a thread is alive from the moment the <code>start</code> method returns until its <code>run</code> method terminates.</p>
</dd>
<dt class="method" id="Thread.isDaemon"><b>isDaemon()</b> <tt class="nav"><a class="nav" href="threading.Thread.isDaemon" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Return the thread's daemon flag.</p>
</dd>
<dt class="method" id="Thread.setDaemon"><b>setDaemon(daemonic)</b> <tt class="nav"><a class="nav" href="threading.Thread.setDaemon" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Set the thread's daemon flag to the Boolean value <var>
daemonic</var>. This must be called before <code>start</code> is called.</p>

<p>The initial value is inherited from the creating thread.</p>

<p>The entire Python program exits when no active non-daemon
threads are left.</p>
</dd>
</dl><div class="text">
<h2 id="timer-objects">Timer Objects <a class="nav" href="#timer-objects">#</a></h2>

<p>This class represents an action that should be run only after a
certain amount of time has passed -- a timer. <a class="link" href="#Timer"><code>Timer</code></a> is a subclass of <a class="link" href="#Thread"><code>Thread</code></a> and as such also functions as an
example of creating custom threads.</p>

<p>Timers are started, as with threads, by calling their <code>start</code> method. The timer can be
stopped (before its action has begun) by calling the <code>cancel</code> method. The interval the
timer will wait before executing its action may not be exactly the
same as the interval specified by the user.</p>

<p>For example:</p>

<pre>
def hello():
    print "hello, world"

t = Timer(30.0, hello)
t.start() # after 30 seconds, "hello, world" will be printed
</pre>
</div>
<dl><dt class="class"><b>class Timer(interval, function, args=[],
kwargs={})</b> <tt class="nav"><a class="nav" href="threading.Timer" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>Create a timer that will run <var>function</var> with arguments
<var>args</var> and keyword arguments <var>kwargs</var>, after
<var>interval</var> seconds have passed.</p>
</dd>
<dt class="method" id="Timer.cancel"><b>cancel()</b> <tt class="nav"><a class="nav" href="threading.Timer.cancel" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Stop the timer, and cancel the execution of the timer's action.
This will only work if the timer is still in its waiting stage.</p>
</dd>
</dl></div></body></html>
