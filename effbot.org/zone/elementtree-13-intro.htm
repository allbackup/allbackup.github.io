<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"><link rel="shortcut icon" href="/media/img/effbot.ico"><link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"><link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"><title>Introducing ElementTree&nbsp;1.3</title></head><body data-page-id="2008"><div id="doc2" class="yui-t2"><div id="hd"></div><div id="bd"><div id="yui-main"><div class="yui-b"><div class="content"><div class="yui-g"><h1 class="maintitle">Introducing ElementTree&nbsp;1.3</h1></div><div class="yui-ge"><div class="yui-u first"><p class="info">Fredrik Lundh | September 2007</p><h2 id="episode-i-the-boring-parts">Episode I: The Boring Parts&#160;<a class="nav" href="#episode-i-the-boring-parts" title="bookmark!">#</a></h2><p>ElementTree 1.3 is an incremental update to the ElementTree 1.2.6 library.  You can get the latest ET 1.3 alpha via Subversion, from here:</p><blockquote><p><a href="http://svn.effbot.org/public/elementtree-1.3/">http://svn.effbot.org/public/elementtree-1.3/</a></p></blockquote><p>Or here, if you prefer a stable link to the current alpha:</p><blockquote><p><a href="http://svn.effbot.org/public/tags/elementtree-1.3a3-20070912/">http://svn.effbot.org/public/tags/elementtree-1.3a3-20070912/</a></p></blockquote><p>(To install, use <strong>svn co</strong> or <strong>svn export</strong> on one of the above URI:s, and then run the <strong>setup.py</strong> script.)</p><p>There&#8217;s also a companion version of cElementTree, tentatively called 1.0.6. It will appear on a site near you in a not too distant future.</p><p>In the meantime, here&#8217;s an article that covers most of the core enhancements in the first round of alphas.  There&#8217;s a couple of other enhancements coming up as well; they will appear in the first beta release, and deserve their own an article (or two).  But for now, let&#8217;s focus on the ElementTree core.</p><h2 id="element-improvements">Element Improvements&#160;<a class="nav" href="#element-improvements" title="bookmark!">#</a></h2><p>The <strong>Element</strong> class has undergone a few small enhancements.  First, the <strong>Element</strong> callable used to be a factory function, but is now a real class.  This means that you can inherit from it:</p><pre class="python"><span class="pykeyword">class</span> <span class="pyclass">MyElement</span>(Element):
     <span class="pykeyword">def</span> <span class="pyfunction">tostring</span>(self):
         <span class="pykeyword">return</span> ET.tostring(self)</pre><p>This is mostly of academical interest, though.  The ET philosophy is still geared towards the use of helper functions to manipulate trees.  ET is a Python library, after all.</p><p>The new methods in this class are probably a bit more useful, for most programmers:</p><h3 id="extend">extend&#160;<a class="nav" href="#extend" title="bookmark!">#</a></h3><p><strong>extend</strong> appends items from a sequence to the element, just as for list objects.</p><pre class="python">elem.extend(other.findall(<span class="pystring">"p"</span>))</pre><h3 id="iter">iter&#160;<a class="nav" href="#iter" title="bookmark!">#</a></h3><p><strong>iter</strong> is the new name for <strong>getiterator</strong>; in ET 1.3, it&#8217;s implemented as a generator method, but is otherwise identical to the old version:</p><pre class="python"><span class="pykeyword">for</span> e <span class="pykeyword">in</span> elem.iter():
    ...</pre><p>Note that in 1.2, <strong>getiterator</strong> returns a list.  To get the same behaviour in 1.3, use the <strong>list</strong> function:</p><pre class="python">elements = list(elem.iter())
<span class="pykeyword">assert</span> isinstance(elements, list)</pre><h3 id="itertext">itertext&#160;<a class="nav" href="#itertext" title="bookmark!">#</a></h3><p>Finally, <strong>itertext</strong> is a generator method that returns all &#8220;inner text&#8221; in an element.</p><pre class="python"><span class="pykeyword">for</span> text <span class="pykeyword">in</span> elem.itertext():
    <span class="pykeyword">print</span> repr(text)

file.writelines(elem.itertext())</pre><p>The generated sequence include data from the <strong>text</strong> attribute for the element itself, and from the <strong>text</strong> and <strong>tail</strong> attributes for all subelements.</p><p>To get all text as a single string, use the <strong>join</strong> method:</p><pre class="python"><span class="pykeyword">def</span> <span class="pyfunction">gettext</span>(elem):
    <span class="pykeyword">return</span> <span class="pystring">""</span>.join(elem.itertext())</pre><h2 id="parser-improvements">Parser Improvements&#160;<a class="nav" href="#parser-improvements" title="bookmark!">#</a></h2><p>The various parser functions (<strong>parse</strong>, <strong>XML</strong>, <strong>fromstring</strong>, and the <strong>parse</strong> method in the ElementTree class) are now all based on the <strong>XMLParser</strong> class (more on this below).</p><p>This parser now raises a <strong>ParseError</strong> exception if something goes wrong.  This exception is a subclass of <strong>SyntaxError</strong>, with an additional <strong>position</strong> attribute that contains the row number (starting at one) and the column number for where the error was found.</p><pre class="python"><span class="pykeyword">try</span>:
    elem = ET.XML(text)
<span class="pykeyword">except</span> ET.ParseError, v:
    row, column = v.position
    <span class="pykeyword">print</span> <span class="pystring">"error on row"</span>, row, <span class="pystring">"column"</span>, column, <span class="pystring">":"</span>, v</pre><p>All parser functions now take an optional <strong>parser</strong> keyword argument, which can be used to explicity pass in a parser instance.  You can use this to override the document encoding:</p><pre class="python">parser = ET.XMLParser(encoding=<span class="pystring">"utf-8"</span>)
root = ET.parse(<span class="pystring">"file.xml"</span>, parser=parser)</pre><p>See <em>Other Changes</em> below for more on this.</p><h2 id="writer-improvements">Writer Improvements&#160;<a class="nav" href="#writer-improvements" title="bookmark!">#</a></h2><p>The <strong>write</strong> method in the <strong>ElementTree</strong> class has undergone a complete overhaul, and now uses a new, more flexible serializer framework.  Some highlights:</p><ul><li><p>The new serializer puts all namespace declarations on the root element.  No more duplicate <strong>xmlns</strong> attributes on sibling elements.</p></li><li><p>The serializer can produce XML, HTML, and plain text output.</p></li><li><p>When generating XML, you can control how the XML declaration is omitted (always, never, or only when needed, as in 1.2).  There&#8217;s also an experimental feature (at least in the alphas) that lets you to specify a default namespace.</p></li><li><p>There&#8217;s an official API for the standard prefix table; no need to add stuff to an internal dictionary.</p></li><li><p>The serializer omits the start and end tag for elements for which the <strong>tag</strong> attribute is set to None; this can be used to quickly remove an element from a tree, without losing the content.</p></li><li><p>The new serializer is a <em>lot</em> faster.  On a selection of typical XML files, it&#8217;s about twice as fast as the one in 1.2.6 (Python 2.5), in my tests.  Your milage may vary, of course, but it should be faster than before on all trees.</p></li></ul><h3 id="xml-output">XML Output&#160;<a class="nav" href="#xml-output" title="bookmark!">#</a></h3><p>XML is the default output format, and works pretty much as in 1.2:</p><pre class="python">tree.write(<span class="pystring">"out.xml"</span>)

tree.write(<span class="pystring">"out.xml"</span>, method=<span class="pystring">"xml"</span>)</pre><p>You can provide an encoding, if necessary:</p><pre class="python">tree.write(<span class="pystring">"out.xml"</span>, encoding=<span class="pystring">"utf-8"</span>)</pre><p>As before, the serializer uses character references for character data and attribute values that cannot be encoded in the given encoding.  However, in 1.3, only the offending character is escaped, rather than the whole text fragment.</p><p>You can use the <strong>register_namespace</strong> function to add &#8220;well-known&#8221; prefixes to the serializer.</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"><pre class="python wide wide">ET.register_namespace(<span class="pystring">"dc"</span>, <span class="pystring">"http://purl.org/dc/elements/1.1/"</span>)</pre></div><div class="yui-ge"><div class="yui-u first"><p>This adds the &#8220;dc&#8221; prefix to a global table.  There&#8217;s no way to specify prefixes only for a given call to <strong>write</strong>; that may be fixed before the final release.</p><p>You can use the <strong>xml_declaration</strong> option to control if an XML declaration should be output or not.  If True, the declaration is always written.  If False, the declaration is never written.  If omitted or None, ET 1.3 uses the old ET 1.2 behaviour, which</p><pre class="python">tree.write(<span class="pystring">"out.xml"</span>, xml_declaration=True)</pre><p>The <strong>default_namespace</strong> attribute specifies a namespace that should be used as the default in the file.  The serializer will put the necessary <strong>xmlns</strong> attribute on the root element, and omit the prefix for all elements that belong to this namespace:</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"><pre class="python wide wide">tree.write(<span class="pystring">"out.xml"</span>, default_namespace=<span class="pystring">"http://www.w3.org/1999/xhtml"</span>)</pre></div><div class="yui-ge"><div class="yui-u first"><p>This feature is somewhat experimental in the current alpha.  Among other things, <em>all</em> elements in the tree must use a namespace for this to work; the default namespace cannot be &#8220;undeclared&#8221;.</p><h3 id="html-output">HTML Output&#160;<a class="nav" href="#html-output" title="bookmark!">#</a></h3><p>The <strong>html</strong> output method is similar to XML, but omits the end tags for elements like <strong>link</strong>, <strong>input</strong>, etc.  It also handles <strong>script</strong> and <strong>style</strong> elements properly, and uses HTML-specific quoting for attribute values.  To get HTML output, pass in <strong>html</strong> to the <strong>method</strong> option:</p><pre class="python">tree.write(<span class="pystring">"out.html"</span>, method=<span class="pystring">"html"</span>)</pre><p>The <strong>html</strong> output method is still a bit experimental, and may be modified somewhat before the final release.  Bug reports and other suggestions are welcome.</p><h3 id="text-output">Text Output&#160;<a class="nav" href="#text-output" title="bookmark!">#</a></h3><p>The <strong>text</strong> output method simply skips all tags, and just outputs the contents of the <strong>text</strong> and <strong>tail</strong> attributes, in the given encoding.</p><pre class="python">tree.write(<span class="pystring">"out.txt"</span>, method=<span class="pystring">"text"</span>, encoding=<span class="pystring">"utf-8"</span>)</pre><p>This is similar to <strong>itertext</strong>, except that the output is encoded, and the tail attribute on the root element is included in the output.</p><h2 id="other-changes">Other changes&#160;<a class="nav" href="#other-changes" title="bookmark!">#</a></h2><h3 id="xmlparser">XMLParser&#160;<a class="nav" href="#xmlparser" title="bookmark!">#</a></h3><p>The <strong>XMLParser</strong> classes replaces the old <strong>XMLTreeBuilder</strong> class (the old name is still available, of course).  The parser now takes an optional <strong>encoding</strong> argument, which can be used to override the file&#8217;s internal encoding:</p><pre class="python">parser = ET.XMLParser(encoding=<span class="pystring">"utf-8"</span>)
parser.feed(data)
elem = parser.close()</pre><p>You can also pass a configured parser object to the <strong>parse</strong>, <strong>fromstring</strong>, and <strong>XML</strong> functions:</p><pre class="python">parser = ET.XMLParser(encoding=<span class="pystring">"utf-8"</span>)
tree = ET.parse(source, parser=parser)</pre><p>The <strong>encoding</strong> option is most often used to parse XML that might have been transcoded, such as when sent over HTTP.  You can also use it to parse XML available as Unicode:</p><pre class="python">elem = XML(
    text.encode(<span class="pystring">"utf-8"</span>),
    parser=XMLParser(encoding=<span class="pystring">"utf-8"</span>)
)</pre><p>The <strong>tostring</strong> and <strong>fromstring</strong> functions have gotten <strong>tostringlist</strong> and <strong>fromstringlist</strong> companions; they work in the same way, but works on lists of string fragments instead of strings.</p><p><strong>fromstring</strong> and <strong>fromstringlist</strong> both take an optional <strong>parser</strong> keyword argument.  Likewise, <strong>tostring</strong> and <strong>tostringlist</strong> both take an optional <strong>method</strong> argument.</p><h2 id="performance">Performance&#160;<a class="nav" href="#performance" title="bookmark!">#</a></h2><p>The most notable performance improvement is the new serializer; in my tests, it&#8217;s usually about twice as fast as the one in 1.2.6.</p><p>Parsing speed is similar to before, but ElementTree now allows you to use the parser from cElementTree 1.0.6 to build ordinary trees.  To enable this feature, do:</p><pre class="python"><span class="pykeyword">import</span> elementtree.ElementTree <span class="pykeyword">as</span> ET
<span class="pykeyword">import</span> cElementTree

ET.XMLParser = cElementTree.XMLParser</pre><p>Note that this requires cElementTree 1.0.6 or later; a bug in the internal tree builder in earlier versions makes it in-compatible with ElementTree 1.3.</p><h2 id="deprecated-and-removed-features">Deprecated and Removed Features&#160;<a class="nav" href="#deprecated-and-removed-features" title="bookmark!">#</a></h2><h3 id="getchildren">getchildren&#160;<a class="nav" href="#getchildren" title="bookmark!">#</a></h3><p><strong>getchildren</strong> is deprecated, and issues a warning.  You can use sequence operations on the element itself instead:</p><pre class="python"><span class="pykeyword">for</span> e <span class="pykeyword">in</span> elem.getchildren():
    ...

<span class="pykeyword">for</span> e <span class="pykeyword">in</span> elem:
    ...</pre><p>If you need a list object, use <strong>list</strong> to convert the Element sequence to a list object:</p><pre class="python">children = list(elem)
<span class="pykeyword">assert</span> isinstance(children, list)</pre><h3 id="getiterator">getiterator&#160;<a class="nav" href="#getiterator" title="bookmark!">#</a></h3><p>The <strong>getiterator</strong> method has been replaced by <strong>iter</strong> (which is also a true iterator in 1.3).  This applies to both <strong>Element</strong> and <strong>ElementTree</strong>.  The old version still works as before; it will be deprecated in the next release.</p><h3 id="truth-testing">Truth testing&#160;<a class="nav" href="#truth-testing" title="bookmark!">#</a></h3><p>The <strong>Element</strong> type now issues a warning when used in a &#8220;boolean context&#8221;.  To get rid of the warning, make the test explicit:</p><pre class="python"><span class="pykeyword">if</span> len(elem):
    ... has at least one children ...

elem = root.find(<span class="pystring">"tag"</span>)
<span class="pykeyword">if</span> elem <span class="pykeyword">is</span> <span class="pykeyword">not</span> None:
    ... found ...</pre><p>Explicit tests work just fine in ET 1.2, of course.</p><p>The boolean interpretation will most likely change in future versions, so that all elements evaluate to true, also if they have no children.</p><h3 id="simplexmltreebuilder">SimpleXMLTreeBuilder&#160;<a class="nav" href="#simplexmltreebuilder" title="bookmark!">#</a></h3><p>The <strong>SimpleXMLTreeBuilder</strong> module has been removed.  This module used <strong>xmllib</strong> to do the parsing, but since <strong>expat</strong> has been available from since around Python 2.0 or so, keeping the old support is pretty pointless.</p><p class="note"><strong>Note:</strong> Unless you&#8217;re using Jython, I&#8217;m told.  It will be
back in the next alpha, at least temporarily, but will issue
a DeprecationWarning for other platforms.</p><h3 id="sgmloptreebuilder">SgmlopTreeBuilder&#160;<a class="nav" href="#sgmloptreebuilder" title="bookmark!">#</a></h3><p>The <strong>SgmlopTreeBuilder</strong> module has been removed; for maximum performance, use <strong>cElementTree</strong> instead.  You can also use cElementTree&#8217;s XMLParser with ET 1.3; see the performance section above for details.</p><h3 id="xmltreebuilder">XMLTreeBuilder&#160;<a class="nav" href="#xmltreebuilder" title="bookmark!">#</a></h3><p>The <strong>XMLTreeBuilder</strong> module has been removed.  For detailed namespace access, use <strong>iterparse</strong> and the <strong>start-ns</strong> and <strong>end-ns</strong> events.</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"></div></div></div></div><div class="yui-b"><div id='menu'><ul><li><b><a href="/" title="Go to effbot.org.">::: effbot.org</a></b></li><li><b><a href="." title="Go to zone index page.">::: zone :::</a></b></li></ul><ul><li><b>::: contents</b></li></ul><ul><li><ul><li><a href="#episode-i-the-boring-parts">Episode I: The Boring Parts</a></li><li><a href="#element-improvements">Element Improvements</a></li><li><ul><li><a href="#extend">extend</a></li><li><a href="#iter">iter</a></li><li><a href="#itertext">itertext</a></li></ul></li><li><a href="#parser-improvements">Parser Improvements</a></li><li><a href="#writer-improvements">Writer Improvements</a></li><li><ul><li><a href="#xml-output">XML Output</a></li><li><a href="#html-output">HTML Output</a></li><li><a href="#text-output">Text Output</a></li></ul></li><li><a href="#other-changes">Other changes</a></li><li><ul><li><a href="#xmlparser">XMLParser</a></li></ul></li><li><a href="#performance">Performance</a></li><li><a href="#deprecated-and-removed-features">Deprecated and Removed Features</a></li><li><ul><li><a href="#getchildren">getchildren</a></li><li><a href="#getiterator">getiterator</a></li><li><a href="#truth-testing">Truth testing</a></li><li><a href="#simplexmltreebuilder">SimpleXMLTreeBuilder</a></li><li><a href="#sgmloptreebuilder">SgmlopTreeBuilder</a></li><li><a href="#xmltreebuilder">XMLTreeBuilder</a></li></ul></li></ul></li></ul></div></div></div><div id="ft"><p><a href="http://www.djangoproject.com/"><img src="/media/img/djangosite80x15.gif" border="0" alt="A Django site." title="A Django site." style="vertical-align: bottom;" width="80" height="15" ></a>
rendered by a <a href="http://www.djangoproject.com/">django</a> application.  hosted by <a href="http://www.webfaction.com/shared_hosting?affiliate=slab">webfaction</a>.</p></div></div><script src="/media/js/effbot-min.js" type="text/javascript"></script></body></html>
