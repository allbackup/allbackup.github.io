
@@module asynchat

<h1>asynchat&#8212;Asynchronous socket command/response handler</h1>

<p>This module builds on the {@link asyncore} infrastructure,
simplifying asynchronous clients and servers and making it easier to
handle protocols whose elements are terminated by arbitrary strings, or
are of variable length. {@link asynchat} defines the abstract class
{@link async_chat} that you subclass, providing implementations of the
{@link collect_incoming_data} and {@link found_terminator} methods. It
uses the same asynchronous loop as {@link asyncore}, and the two types
of channel, {@link asyncore.dispatcher} and {@link asynchat.async_chat},
can freely be mixed in the channel map. Typically an {@link
asyncore.dispatcher} server channel generates new {@link
asynchat.async_chat} channel objects as it receives incoming connection
requests.

@@class async_chat()

<p>This class is an abstract subclass of {@link asyncore.dispatcher}. To
make practical use of the code you must subclass {@link async_chat},
providing meaningful {@link collect_incoming_data} and {@link
found_terminator} methods. The {@link asyncore.dispatcher} methods can
be used, although not all make sense in a message/response context.

<p>Like {@link asyncore.dispatcher}, {@link async_chat} defines a set of
events that are generated by an analysis of socket conditions after a
{@link c:select} call. Once the polling loop has been started the {@link
async_chat} object's methods are called by the event-processing
framework with no action on the part of the programmer.

<p>Unlike {@link asyncore.dispatcher}, {@link async_chat} allows you to
define a first-in-first-out queue (fifo) of {@em producers}. A producer
need have only one method, {@link more}, which should return data to be
transmitted on the channel. The producer indicates exhaustion (i.e. that
it contains no more data) by having its {@link more} method return the
empty string. At this point the {@link async_chat} object removes the
producer from the fifo and starts using the next producer, if any. When
the producer fifo is empty the {@link handle_write} method does nothing.
You use the channel object's {@link set_terminator} method to describe
how to recognize the end of, or an important breakpoint in, an incoming
transmission from the remote endpoint.

<p>To build a functioning {@link async_chat} subclass your input methods
{@link collect_incoming_data} and {@link found_terminator} must handle
the data that the channel receives asynchronously. The methods are
described below.

@@method async_chat.close_when_done()

<p>Pushes a {@link None} on to the producer fifo. When this producer is
popped off the fifo it causes the channel to be closed.

@@method async_chat.collect_incoming_data(data)

<p>Called with {@var data} holding an arbitrary amount of received data.
The default method, which must be overridden, raises a {@link
exceptions.NotImplementedError} exception.

@@method async_chat.discard_buffers()

<p>In emergencies this method will discard any data held in the input
and/or output buffers and the producer fifo.

@@method async_chat.found_terminator()

<p>Called when the incoming data stream matches the termination
condition set by {@link set_terminator}. The default method, which must
be overridden, raises a {@link exceptions.NotImplementedError}
exception. The buffered input data should be available via an instance
attribute.

@@method async_chat.get_terminator()

<p>Returns the current terminator for the channel.

@@method async_chat.handle_close()

<p>Called when the channel is closed. The default method silently closes
the channel's socket.

@@method async_chat.handle_read()

<p>Called when a read event fires on the channel's socket in the
asynchronous loop. The default method checks for the termination
condition established by {@link set_terminator}, which can be either the
appearance of a particular string in the input stream or the receipt of
a particular number of characters. When the terminator is found, {@link
handle_read} calls the {@link found_terminator} method after calling
{@link collect_incoming_data} with any data preceding the terminating
condition.

@@method async_chat.handle_write()

<p>Called when the application may write data to the channel. The
default method calls the {@link initiate_send} method, which in turn
will call {@link refill_buffer} to collect data from the producer fifo
associated with the channel.

@@method async_chat.push(data)

<p>Creates a {@link simple_producer} object ({@em see below}) containing
the data and pushes it on to the channel's {@code producer_fifo} to
ensure its transmission. This is all you need to do to have the channel
write the data out to the network, although it is possible to use your
own producers in more complex schemes to implement encryption and
chunking, for example.

@@method async_chat.push_with_producer(producer)

<p>Takes a producer object and adds it to the producer fifo associated
with the channel. When all currently-pushed producers have been
exhausted the channel will consume this producer's data by calling its
{@link more} method and send the data to the remote endpoint.

@@method async_chat.readable()

<p>Should return {@link True} for the channel to be included in the set
of channels tested by the {@link c:select} loop for readability.

@@method async_chat.refill_buffer()

<p>Refills the output buffer by calling the {@link more} method of the
producer at the head of the fifo. If it is exhausted then the producer
is popped off the fifo and the next producer is activated. If the
current producer is, or becomes, {@link None} then the channel is
closed.

@@method async_chat.set_terminator(term)

<p>Sets the terminating condition to be recognised on the channel.
{@code term} may be any of three types of value, corresponding to three
different ways to handle incoming protocol data.

<p><table border=1>
<tr> <th>
<p>term
<th>
<p>Description
<tr> <td>
<p>{@em string}
<td>
<p>Will call {@link found_terminator} when the string is found in the
input stream
<tr> <td>
<p>{@em integer}
<td>
<p>Will call {@link found_terminator} when the indicated number of
characters have been received
<tr> <td>
<p>{@link None}
<td>
<p>The channel continues to collect data forever
</table></p>

<p>Note that any data following the terminator will be available for
reading by the channel after {@link found_terminator} is called.

@@method async_chat.writable()

<p>Should return {@link True} as long as items remain on the producer
fifo, or the channel is connected and the channel's output buffer is
non-empty.

@@text 

<h2>asynchat - Auxiliary Classes and Functions</h2>

@@class simple_producer(data[, buffer_size=512])

<p>A {@link simple_producer} takes a chunk of data and an optional
buffer size. Repeated calls to its {@link more} method yield successive
chunks of the data no larger than {@var buffer_size}.

@@method simple_producer.more()

<p>Produces the next chunk of information from the producer, or returns
the empty string.

@@class fifo([list=None])

<p>Each channel maintains a {@link fifo} holding data which has been
pushed by the application but not yet popped for writing to the channel.
A {@link fifo} is a list used to hold data and/or producers until they
are required. If the {@var list} argument is provided then it should
contain producers or data items to be written to the channel.

@@method fifo.is_empty()

<p>Returns {@link True} iff the fifo is empty.

@@method fifo.first()

<p>Returns the least-recently {@link push}ed item from the fifo.

@@method fifo.push(data)

<p>Adds the given data (which may be a string or a producer object) to
the producer fifo.

@@method fifo.pop()

<p>If the fifo is not empty, returns {@code True, first()}, deleting the
popped item. Returns {@code False, None} for an empty fifo.

@@text 

<p>The {@link asynchat} module also defines one utility function, which
may be of use in network and textual analysis operations.

@@function find_prefix_at_end(haystack, needle)

<p>Returns {@link True} if string {@var haystack} ends with any
non-empty prefix of string {@var needle}.

@@text 

<h2>asynchat Example</h2>

<p>The following partial example shows how HTTP requests can be read
with {@link async_chat}. A web server might create an {@link
http_request_handler} object for each incoming client connection. Notice
that initially the channel terminator is set to match the blank line at
the end of the HTTP headers, and a flag indicates that the headers are
being read.

<p>Once the headers have been read, if the request is of type POST
(indicating that further data are present in the input stream) then the
{@code Content-Length:} header is used to set a numeric terminator to
read the right amount of data from the channel.

<p>The {@link handle_request} method is called once all relevant input
has been marshalled, after setting the channel terminator to {@link
None} to ensure that any extraneous data sent by the web client are
ignored.

<pre>
class http_request_handler(asynchat.async_chat):

    def __init__(self, conn, addr, sessions, log):
        asynchat.async_chat.__init__(self, conn=conn)
        self.addr = addr
        self.sessions = sessions
        self.ibuffer = []
        self.obuffer = ""
        self.set_terminator("\r\n\r\n")
        self.reading_headers = True
        self.handling = False
        self.cgi_data = None
        self.log = log

    def collect_incoming_data(self, data):
        """Buffer the data"""
        self.ibuffer.append(data)

    def found_terminator(self):
        if self.reading_headers:
            self.reading_headers = False
            self.parse_headers("".join(self.ibuffer))
            self.ibuffer = []
            if self.op.upper() == "POST":
                clen = self.headers.getheader("content-length")
                self.set_terminator(int(clen))
            else:
                self.handling = True
                self.set_terminator(None)
                self.handle_request()
        elif not self.handling:
            self.set_terminator(None) # browsers sometimes over-send
            self.cgi_data = parse(self.headers, "".join(self.ibuffer))
            self.handling = True
            self.ibuffer = []
            self.handle_request()
</pre>

