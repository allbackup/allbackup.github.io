<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml"> <link rel="shortcut icon" href="/media/img/effbot.ico"> <link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"> <link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"> <title>reload</title> <script type="text/javascript">effbot_page_id=1530;</script> </head> <body> <div id="doc2" class="yui-t2"> <div id="hd"> <!-- header --> </div> <!-- hd --> <div id="bd"> <!-- body --> <div id="yui-main"> <div class="yui-b"> <div class="content"><div class="yui-g"> <h1 class="maintitle">reload</h1> </div> <!-- yui-g --><div class="yui-ge"><div class="yui-u first"><p><strong>reload</strong>(module)</p><p>Reloads a previously imported module. The argument must be a module
object, so it must have been successfully imported before. This is
useful if you have edited the module source file using an external
editor and want to try out the new version without leaving the Python
interpreter. The return value is the module object (the same as the
module argument).</p><p>When <code>reload(module)</code> is executed:</p><ul><li><p>Python modules&#8217; code is recompiled and the module-level code
reexecuted, defining a new set of objects which are bound to names in
the module&#8217;s dictionary. The <code>init</code> function of extension modules is
not called a second time.</p></li><li><p>As with all other objects in Python the old objects are only
reclaimed after their reference counts drop to zero.</p></li><li><p>The names in the module namespace are updated to point to any new
or changed objects.</p></li><li><p>Other references to the old objects (such as names external to the
module) are not rebound to refer to the new objects and must be
updated in each namespace where they occur if that is desired.</p></li></ul><p>There are a number of other caveats:</p><p>If a module is syntactically correct but its initialization fails, the
first import statement for it does not bind its name locally, but does
store a (partially initialized) module object in <code>sys.modules</code>. To
reload the module you must first import it again (this will bind the
name to the partially initialized module object) before you can
<strong>reload</strong> it.</p><p>When a module is reloaded, its dictionary (containing the module&#8217;s
global variables) is retained. Redefinitions of names will override
the old definitions, so this is generally not a problem. If the new
version of a module does not define a name that was defined by the old
version, the old definition remains. This feature can be used to the
module&#8217;s advantage if it maintains a global table or cache of objects
&#8212; with a <a href="try.htm"><strong>try</strong></a> statement it can test for the table&#8217;s presence and
skip its initialization if desired:</p><pre class="python"><span class="pykeyword">try</span>:
    cache
<span class="pykeyword">except</span> NameError:
    cache = {}</pre><p>It is legal though generally not very useful to reload built-in or
dynamically loaded modules, except for <a href="sys.htm"><strong>sys</strong></a>, <a href="__main__.htm"><strong>__main__</strong></a>
and <a href="__builtin__.htm"><strong>__builtin__</strong></a>. In many cases, however, extension modules
are not designed to be initialized more than once, and may fail in
arbitrary ways when reloaded.</p><p>If a module imports objects from another module using from-import,
calling <strong>reload</strong> for the other module does not redefine the
objects imported from it &#8212; one way around this is to re-execute the
from statement, another is to use import and qualified names
(module.name) instead.</p><p>If a module instantiates instances of a class, reloading the module
that defines the class does not affect the method definitions of the
instances &#8212; they continue to use the old class definition. The same
is true for derived classes.</p></div><div class="yui-u">&#160;</div></div><div class="yui-g"></div> <!-- yui-g --></div> <!-- content --> </div> <!-- yui-b --> </div> <!-- yui-main --> <div class="yui-b"> <div id='menu'> <ul> <li><b><a href="/" title="Go to effbot.org.">::: effbot.org</a></b></li> <li><b><a href="." title="Go to pyref index page.">::: pyref :::</a></b></li> </ul> </div> <!-- menu --> </div> <!-- yui-b --> </div> <!-- bd --> <div id="ft"> <!-- footer --> <p><a href="http://www.djangoproject.com/"><img src="/media/img/djangosite80x15.gif" border="0" alt="A Django site." title="A Django site." style="vertical-align: bottom;"></a>
this page was rendered by a <a href="http://www.djangoproject.com/">django</a> application in 0.01s 2011-06-21 22:56:30.494730.  hosted by <a href="http://www.webfaction.com/shared_hosting?affiliate=slab">webfaction</a>.</p> </div> <!-- ft --> </div> <!-- doc --> <script src="/media/js/effbot-min.js" type="text/javascript"> </script> </body> </html>
