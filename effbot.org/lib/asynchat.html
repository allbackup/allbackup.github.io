<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>asynchat</title>
<style type='text/css'>body { font: 100% Georgia, Times, serif; } a.nav:link, a.nav:visited { color: #88f; } .nav { color: #88f; } a.nav:hover { color: blue; } .mark { color: #048444; }</style>
<meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
</head><body>
<table style='font-size: 8pt; background: #efe; padding: 5px; border: 1px solid #084; margin: 0px 0px 20px 0px;' border='0' cellspacing='0' cellpadding='0' width='100%'><tr><td align='left'>
an alternative python reference (<a href='/zone/pythondoc-lib.htm'>in progress</a>)
</td><td align='right'>
<a href='http://docs.python.org/lib/module-asynchat.html'>original</a> :::
<a href='asynchat.txt'>source</a> :::
<a href='/lib/index.html'>index</a>
</td></tr></table><table style='font-size: 8pt; background: white; padding: 5px; border: 1px solid #084; margin: 0px 0px 20px 0px;' border='0' cellspacing='0' cellpadding='0' width='100%%'><tr><td align='left'>
<b>note:</b> this page has been automatically converted from python.org
sources, and may contain errors and omissions introduced by the conversion
process.
</td></tr></table><div class="body"><div class="module">
<h1>asynchat&#8212;Asynchronous socket command/response
handler</h1>

<div class="toc"><dl><dt>On this page:</dt><dd><a href="#asynchat-auxiliary-classes-and-functions">asynchat - Auxiliary Classes and Functions</a></dd><dd><a href="#asynchat-example">asynchat Example</a></dd></dl></div><p>This module builds on the <code>
asyncore</code> infrastructure, simplifying asynchronous clients and
servers and making it easier to handle protocols whose elements are
terminated by arbitrary strings, or are of variable length. <code>asynchat</code> defines the abstract
class <a class="link" href="#async_chat"><code>async_chat</code></a> that
you subclass, providing implementations of the <code>collect_incoming_data</code> and <code>found_terminator</code>
methods. It uses the same asynchronous loop as <code>asyncore</code>, and the two types of channel, <code>
asyncore.dispatcher</code> and <code>asynchat.async_chat</code>, can freely
be mixed in the channel map. Typically an <code>asyncore.dispatcher</code> server
channel generates new <code>asynchat.async_chat</code> channel
objects as it receives incoming connection requests.</p>
</div>
<dl><dt class="class" id="async_chat"><b>class async_chat()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>This class is an abstract subclass of <code>asyncore.dispatcher</code>. To make
practical use of the code you must subclass <a class="link" href="#async_chat"><code>async_chat</code></a>, providing meaningful <code>
collect_incoming_data</code> and <code>found_terminator</code> methods. The <code>
asyncore.dispatcher</code> methods can be used, although not all make
sense in a message/response context.</p>

<p>Like <code>
asyncore.dispatcher</code>, <a class="link" href="#async_chat"><code>
async_chat</code></a> defines a set of events that are generated by an
analysis of socket conditions after a <code>c:select</code> call. Once the polling loop has
been started the <a class="link" href="#async_chat"><code>
async_chat</code></a> object's methods are called by the event-processing
framework with no action on the part of the programmer.</p>

<p>Unlike <code>
asyncore.dispatcher</code>, <a class="link" href="#async_chat"><code>
async_chat</code></a> allows you to define a first-in-first-out queue
(fifo) of <em>producers</em>. A producer need have only one method,
<code>more</code>, which should return data
to be transmitted on the channel. The producer indicates exhaustion
(i.e. that it contains no more data) by having its <code>more</code> method return the empty string. At this
point the <a class="link" href="#async_chat"><code>async_chat</code></a>
object removes the producer from the fifo and starts using the next
producer, if any. When the producer fifo is empty the <code>handle_write</code> method does
nothing. You use the channel object's <code>set_terminator</code> method to describe
how to recognize the end of, or an important breakpoint in, an
incoming transmission from the remote endpoint.</p>

<p>To build a functioning <a class="link" href="#async_chat"><code>
async_chat</code></a> subclass your input methods <code>collect_incoming_data</code> and <code>found_terminator</code> must
handle the data that the channel receives asynchronously. The
methods are described below.</p>
</dd>
<dt class="method" id="async_chat.close_when_done"><b>close_when_done()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.close_when_done" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Pushes a <code>None</code> on to the
producer fifo. When this producer is popped off the fifo it causes
the channel to be closed.</p>
</dd>
<dt class="method" id="async_chat.collect_incoming_data"><b>collect_incoming_data(data)</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.collect_incoming_data" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Called with <var>data</var> holding an arbitrary amount of
received data. The default method, which must be overridden, raises
a <code>
exceptions.NotImplementedError</code> exception.</p>
</dd>
<dt class="method" id="async_chat.discard_buffers"><b>discard_buffers()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.discard_buffers" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>In emergencies this method will discard any data held in the
input and/or output buffers and the producer fifo.</p>
</dd>
<dt class="method" id="async_chat.found_terminator"><b>found_terminator()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.found_terminator" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Called when the incoming data stream matches the termination
condition set by <code>
set_terminator</code>. The default method, which must be overridden,
raises a <code>
exceptions.NotImplementedError</code> exception. The buffered input
data should be available via an instance attribute.</p>
</dd>
<dt class="method" id="async_chat.get_terminator"><b>get_terminator()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.get_terminator" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Returns the current terminator for the channel.</p>
</dd>
<dt class="method" id="async_chat.handle_close"><b>handle_close()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.handle_close" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Called when the channel is closed. The default method silently
closes the channel's socket.</p>
</dd>
<dt class="method" id="async_chat.handle_read"><b>handle_read()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.handle_read" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Called when a read event fires on the channel's socket in the
asynchronous loop. The default method checks for the termination
condition established by <code>set_terminator</code>, which can be either
the appearance of a particular string in the input stream or the
receipt of a particular number of characters. When the terminator
is found, <code>handle_read</code>
calls the <code>
found_terminator</code> method after calling <code>collect_incoming_data</code> with
any data preceding the terminating condition.</p>
</dd>
<dt class="method" id="async_chat.handle_write"><b>handle_write()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.handle_write" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Called when the application may write data to the channel. The
default method calls the <code>
initiate_send</code> method, which in turn will call <code>refill_buffer</code> to collect data from
the producer fifo associated with the channel.</p>
</dd>
<dt class="method" id="async_chat.push"><b>push(data)</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.push" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Creates a <a class="link" href="#simple_producer"><code>
simple_producer</code></a> object (<em>see below</em>) containing the data
and pushes it on to the channel's <code>producer_fifo</code> to
ensure its transmission. This is all you need to do to have the
channel write the data out to the network, although it is possible
to use your own producers in more complex schemes to implement
encryption and chunking, for example.</p>
</dd>
<dt class="method" id="async_chat.push_with_producer"><b>push_with_producer(producer)</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.push_with_producer" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Takes a producer object and adds it to the producer fifo
associated with the channel. When all currently-pushed producers
have been exhausted the channel will consume this producer's data
by calling its <code>more</code> method and
send the data to the remote endpoint.</p>
</dd>
<dt class="method" id="async_chat.readable"><b>readable()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.readable" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Should return <code>True</code> for the
channel to be included in the set of channels tested by the <code>c:select</code> loop for
readability.</p>
</dd>
<dt class="method" id="async_chat.refill_buffer"><b>refill_buffer()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.refill_buffer" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Refills the output buffer by calling the <code>more</code> method of the producer at the head of the
fifo. If it is exhausted then the producer is popped off the fifo
and the next producer is activated. If the current producer is, or
becomes, <code>None</code> then the channel
is closed.</p>
</dd>
<dt class="method" id="async_chat.set_terminator"><b>set_terminator(term)</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.set_terminator" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Sets the terminating condition to be recognised on the channel.
<code>term</code> may be any of three types of value, corresponding
to three different ways to handle incoming protocol data.</p>

<table border="1">
<tr>
<th>
<p>term</p>
</th>
<th>
<p>Description</p>
</th>
</tr>

<tr>
<td>
<p><em>string</em></p>
</td>
<td>
<p>Will call <code>
found_terminator</code> when the string is found in the input
stream</p>
</td>
</tr>

<tr>
<td>
<p><em>integer</em></p>
</td>
<td>
<p>Will call <code>
found_terminator</code> when the indicated number of characters have
been received</p>
</td>
</tr>

<tr>
<td>
<p><code>None</code></p>
</td>
<td>
<p>The channel continues to collect data forever</p>
</td>
</tr>
</table>

<br />
<br />
 

<p>Note that any data following the terminator will be available
for reading by the channel after <code>found_terminator</code> is called.</p>
</dd>
<dt class="method" id="async_chat.writable"><b>writable()</b> <tt class="nav"><a class="nav" href="asynchat.async_chat.writable" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Should return <code>True</code> as long
as items remain on the producer fifo, or the channel is connected
and the channel's output buffer is non-empty.</p>
</dd>
</dl><div class="text">
<h2 id="asynchat-auxiliary-classes-and-functions">asynchat - Auxiliary Classes and Functions <a class="nav" href="#asynchat-auxiliary-classes-and-functions">#</a></h2>
</div>
<dl><dt class="class" id="simple_producer"><b>class simple_producer(data[, buffer_size=512])</b> <tt class="nav"><a class="nav" href="asynchat.simple_producer" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>A <a class="link" href="#simple_producer"><code>
simple_producer</code></a> takes a chunk of data and an optional buffer
size. Repeated calls to its <code>
more</code> method yield successive chunks of the data no larger than
<var>buffer_size</var>.</p>
</dd>
<dt class="method" id="simple_producer.more"><b>more()</b> <tt class="nav"><a class="nav" href="asynchat.simple_producer.more" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Produces the next chunk of information from the producer, or
returns the empty string.</p>
</dd>
<dt class="class" id="fifo"><b>class fifo([list=None])</b> <tt class="nav"><a class="nav" href="asynchat.fifo" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="class">
<p>Each channel maintains a <a class="link" href="#fifo"><code>
fifo</code></a> holding data which has been pushed by the application but
not yet popped for writing to the channel. A <a class="link" href="#fifo"><code>fifo</code></a> is a list used to hold data and/or
producers until they are required. If the <var>list</var> argument
is provided then it should contain producers or data items to be
written to the channel.</p>
</dd>
<dt class="method" id="fifo.is_empty"><b>is_empty()</b> <tt class="nav"><a class="nav" href="asynchat.fifo.is_empty" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Returns <code>True</code> iff the fifo
is empty.</p>
</dd>
<dt class="method" id="fifo.first"><b>first()</b> <tt class="nav"><a class="nav" href="asynchat.fifo.first" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Returns the least-recently <code>
push</code>ed item from the fifo.</p>
</dd>
<dt class="method" id="fifo.push"><b>push(data)</b> <tt class="nav"><a class="nav" href="asynchat.fifo.push" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>Adds the given data (which may be a string or a producer object)
to the producer fifo.</p>
</dd>
<dt class="method" id="fifo.pop"><b>pop()</b> <tt class="nav"><a class="nav" href="asynchat.fifo.pop" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="method">
<p>If the fifo is not empty, returns <code>True, first()</code>,
deleting the popped item. Returns <code>False, None</code> for an
empty fifo.</p>
</dd>
</dl><div class="text">
<p>The <code>asynchat</code> module
also defines one utility function, which may be of use in network
and textual analysis operations.</p>
</div>
<dl><dt class="function" id="find_prefix_at_end"><b>find_prefix_at_end(haystack, needle)</b> <tt class="nav"><a class="nav" href="asynchat.find_prefix_at_end" title="bookmark">#</a>|<a class="nav" href="#" title="edit/suggest changes">!</a>|<a class="nav" href="#" title="search for related examples">&amp;</a></tt></dt>

<dd class="function">
<p>Returns <code>True</code> if string
<var>haystack</var> ends with any non-empty prefix of string <var>
needle</var>.</p>
</dd>
</dl><div class="text">
<h2 id="asynchat-example">asynchat Example <a class="nav" href="#asynchat-example">#</a></h2>

<p>The following partial example shows how HTTP requests can be
read with <a class="link" href="#async_chat"><code>async_chat</code></a>. A
web server might create an <code>http_request_handler</code> object
for each incoming client connection. Notice that initially the
channel terminator is set to match the blank line at the end of the
HTTP headers, and a flag indicates that the headers are being
read.</p>

<p>Once the headers have been read, if the request is of type POST
(indicating that further data are present in the input stream) then
the <code>Content-Length:</code> header is used to set a numeric
terminator to read the right amount of data from the channel.</p>

<p>The <code>
handle_request</code> method is called once all relevant input has
been marshalled, after setting the channel terminator to <code>None</code> to ensure that any
extraneous data sent by the web client are ignored.</p>

<pre>
class http_request_handler(asynchat.async_chat):

    def __init__(self, conn, addr, sessions, log):
        asynchat.async_chat.__init__(self, conn=conn)
        self.addr = addr
        self.sessions = sessions
        self.ibuffer = []
        self.obuffer = ""
        self.set_terminator("\r\n\r\n")
        self.reading_headers = True
        self.handling = False
        self.cgi_data = None
        self.log = log

    def collect_incoming_data(self, data):
        """Buffer the data"""
        self.ibuffer.append(data)

    def found_terminator(self):
        if self.reading_headers:
            self.reading_headers = False
            self.parse_headers("".join(self.ibuffer))
            self.ibuffer = []
            if self.op.upper() == "POST":
                clen = self.headers.getheader("content-length")
                self.set_terminator(int(clen))
            else:
                self.handling = True
                self.set_terminator(None)
                self.handle_request()
        elif not self.handling:
            self.set_terminator(None) # browsers sometimes over-send
            self.cgi_data = parse(self.headers, "".join(self.ibuffer))
            self.handling = True
            self.ibuffer = []
            self.handle_request()
</pre>
</div>
</div></body></html>
