<html>
<head>
<title>image ::: www.effbot.org</title>
<link rel='stylesheet' href='/effbot.css' type='text/css' media='screen' />
</head>
<body bgcolor='#ccffcc'>
<div>[<a href='image.htm'>back</a>]</div>
<h3>Welcome to the effbot.org user editor!</h3>


<p><b>Note: This is not a contact form!  Support questions, spam, and
other off-topic stuff will be ignored.</b></p>

<p>To suggest changes, edit the HTML fragment in the text box below.
You can use the 'update preview' button to check your changes (the
preview is displayed beneath the text box).  When done, fill in the
name and address fields (optional) and click 'submit patch' to mail
the patch to me.  (I reserve the right to decide which patches to
include, of course.)  Thanks! /F</p>

<form method='post' id='useredit'>
<input type='hidden' name='name' value='image'/>
<p>
<input type='submit' name='preview' value='update preview' style='background:#084; color:white; width:200px; font-weight:bold;' >
&nbsp;&nbsp;&nbsp;
<input type='submit' name='submit' value='submit patch'  style='background:#084; color:white; width:200px; font-weight:bold;' >
</p>
<textarea name='text' rows='30' cols='80'>The Image Module

&lt;!-- LINK PREV concepts.htm --&gt;
&lt;!-- LINK NEXT imagechops.htm --&gt;

&lt;p&gt;The &lt;b&gt;Image&lt;/b&gt; module provides a class with the same name which
is used to represent a PIL image. The module also provides a number of
factory functions, including functions to load images from files, and
to create new images.&lt;/p&gt;

&lt;h2 id='examples'&gt;Examples&lt;/h2&gt;

&lt;p&gt;The following script loads an image, rotates it 45 degrees, and
displays it using an external viewer (usually &lt;b&gt;xv&lt;/b&gt; on Unix, and
the &lt;b&gt;paint&lt;/b&gt; program on Windows).&lt;/p&gt;

&lt;div class='example'&gt;
&lt;b&gt;Open, rotate, and display an image (using the default viewer)&lt;/b&gt;
&lt;pre&gt;
from PIL import Image
im = Image.open("bride.jpg")
im.rotate(45).show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The following script creates nice 128x128 thumbnails of all JPEG
images in the current directory.&lt;/p&gt;

&lt;div class='example'&gt;
&lt;b&gt;Create thumbnails&lt;/b&gt;
&lt;pre&gt;
from PIL import Image
import glob, os

size = 128, 128

for infile in glob.glob("*.jpg"):
    file, ext = os.path.splitext(infile)
    im = Image.open(infile)
    im.thumbnail(size, Image.ANTIALIAS)
    im.save(file + ".thumbnail", "JPEG")
&lt;/pre&gt;
&lt;/div&gt;

&lt;h2&gt;Functions&lt;/h2&gt;

&lt;h3 id='new'&gt;new&lt;/h3&gt;

&lt;div class='function' id='image-new-function'&gt;

&lt;p&gt;&lt;b&gt;Image.new(mode, size)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Image.new(mode, size, color)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates a new image with the given mode and size. Size is given as
a 2-tuple. The colour is given as a single value for single-band
images, and a tuple for multi-band images (with one value for each
band).  If the colour argument is omitted, the image is filled with
black.  If the colour is None, the image is not initialised.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='open'&gt;open&lt;/h3&gt;

&lt;div class='function' id="image-open-function"&gt;

&lt;p&gt;&lt;b&gt;Image.open(infile)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Image.open(infile, mode)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Opens and identifies the given image file.  This is a lazy
operation; the actual image data is not read from the file until you
try to process the data (call the &lt;b&gt;load&lt;/b&gt; method to force
loading).  If the mode argument is given, it must be "r".&lt;/p&gt;

&lt;p&gt;You can use either a string (representing the filename) or a file
object. In the latter case, the file object must implement
&lt;b&gt;read&lt;/b&gt;, &lt;b&gt;seek&lt;/b&gt;, and &lt;b&gt;tell&lt;/b&gt; methods, and be opened in
binary mode.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='blend'&gt;blend&lt;/h3&gt;

&lt;div class='function' id="image-blend-function"&gt;

&lt;p&gt;&lt;b&gt;Image.blend(image1, image2, alpha)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates a new image by interpolating between the given images,
using a constant alpha.  Both images must have the same size and
mode.&lt;/p&gt;

&lt;pre&gt;
    out = image1 * (1.0 - alpha) + image2 * alpha
&lt;/pre&gt;

&lt;p&gt;If alpha is 0.0, a copy of the first image is returned. If alpha
is 1.0, a copy of the second image is returned. There are no
restrictions on the alpha value. If necessary, the result is
clipped to fit into the allowed output range.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='composite'&gt;composite&lt;/h3&gt;

&lt;div class='function' id="image-composite-function"&gt;

&lt;p&gt;&lt;b&gt;Image.composite(image1, image2, mask)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates a new image by interpolating between the given images,
using the mask as alpha.  The mask image can have mode "1", "L", or
"RGBA".  All images must be the same size.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='eval'&gt;eval&lt;/h3&gt;

&lt;div class='function' id="image-eval-function"&gt;

&lt;p&gt;&lt;b&gt;Image.eval(image, function)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Applies the function (which should take one argument) to each
pixel in the given image. If the image has more than one band, the
same function is applied to each band. Note that the function is
evaluated once for each possible pixel value, so you cannot use
random components or other generators.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='frombuffer'&gt;frombuffer&lt;/h3&gt;

&lt;div class='function' id="image-frombuffer-function"&gt;

&lt;p&gt;&lt;b&gt;Image.frombuffer(mode, size, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;(New in PIL 1.1.4).  Creates an image memory from pixel data in a
string or buffer object, using the standard "raw" decoder.  For some
modes, the image memory will share memory with the original buffer
(this means that changes to the original buffer object are reflected
in the image).  Not all modes can share memory; supported modes
include "L", "RGBX", "RGBA", and "CMYK".  For other modes, this
function behaves like a corresponding call to the &lt;b&gt;fromstring&lt;/b&gt;
function.&lt;/p&gt;

&lt;p class='note'&gt;&lt;b&gt;Note:&lt;/b&gt; In versions up to 1.1.6, the default
orientation differs from that of &lt;b&gt;fromstring&lt;/b&gt;.  This may be
changed in future versions, so for maximum portability, it's
recommended that you spell out all arguments when using the "raw"
decoder:&lt;/p&gt;

&lt;pre&gt;
im = Image.frombuffer(mode, size, data, "raw", mode, 0, 1)
&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;Image.frombuffer(mode, size, data, decoder, parameters)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Same as the corresponding &lt;b&gt;fromstring&lt;/b&gt; call.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='fromstring'&gt;fromstring&lt;/h3&gt;

&lt;div class='function' id="image-fromstring-function"&gt;

&lt;p&gt;&lt;b&gt;Image.fromstring(mode, size, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates an image memory from pixel data in a string, using the
standard "raw" decoder.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Image.fromstring(mode, size, data, decoder, parameters)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Same, but allows you to use any pixel decoder supported by PIL.
For more information on available decoders, see the section &lt;a
href="pil-decoder.htm"&gt;&lt;i&gt;Writing Your Own File Decoder&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Note that this function decodes pixel data, not entire images.  If
you have an entire image file in a string, wrap it in a &lt;b&gt;StringIO&lt;/b&gt;
object, and use &lt;a href="#image-open-function"&gt;&lt;b&gt;open&lt;/b&gt;&lt;/a&gt;
to load it.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='merge'&gt;merge&lt;/h3&gt;

&lt;div class='function' id="image-merge-function"&gt;

&lt;p&gt;&lt;b&gt;Image.merge(mode, bands)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates a new image from a number of single band images. The
bands are given as a tuple or list of images, one for each band
described by the mode. All bands must have the same size.&lt;/p&gt;

&lt;/div&gt;

&lt;h2&gt;Methods&lt;/h2&gt;

&lt;p&gt;An instance of the &lt;b&gt;Image&lt;/b&gt; class has the following methods.
Unless otherwise stated, all methods return a new instance of the
&lt;b&gt;Image&lt;/b&gt; class, holding the resulting image.&lt;/p&gt;

&lt;h3 id='Image.convert'&gt;convert&lt;/h3&gt;

&lt;div class='method' id="image-convert-method"&gt;

&lt;p&gt;&lt;b&gt;im.convert(mode)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a converted copy of an image.&lt;/p&gt;

&lt;p&gt;When translating from a palette image, this translates pixels through
the palette. If mode is omitted, a mode is chosen so that all information
in the image and the palette can be represented without a palette.&lt;/p&gt;

&lt;p&gt;When from a colour image to black and white, the library uses the
ITU-R 601-2 luma transform:&lt;/p&gt;

&lt;pre&gt;
    L = R * 299/1000 + G * 587/1000 + B * 114/1000
&lt;/pre&gt;

&lt;p&gt;When converting to a bilevel image (mode "1"), the source image is
first converted to black and white.  Resulting values larger than 127
are then set to white, and the image is dithered.  To use other thresholds,
use the &lt;b&gt;point&lt;/b&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.convert(mode, matrix)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Converts an "RGB" image to "L" or "RGB" using a conversion
matrix. The matrix is a 4- or 16-tuple.&lt;/p&gt;

&lt;p&gt;The following example converts an RGB image (linearly calibrated
according to ITU-R 709, using the D65 luminant) to the CIE XYZ
colour space:&lt;/p&gt;

&lt;div class='example'&gt;
&lt;b&gt;Convert RGB to XYZ&lt;/b&gt;
&lt;pre&gt;
    rgb2xyz = (
        0.412453, 0.357580, 0.180423, 0,
        0.212671, 0.715160, 0.072169, 0,
        0.019334, 0.119193, 0.950227, 0 )
    out = im.convert("RGB", rgb2xyz)
&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;h3 id='Image.copy'&gt;copy&lt;/h3&gt;

&lt;div id="image-copy-method" class='method'&gt;

&lt;p&gt;&lt;b&gt;im.copy()&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Copies the image. Use this method if you wish to paste things
into an image, but still retain the original.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.crop'&gt;crop&lt;/h3&gt;

&lt;div id="image-crop-method" class='method'&gt;

&lt;p&gt;&lt;b&gt;im.crop(box)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a rectangular region from the current image. The box is
a 4-tuple defining the left, upper, right, and lower pixel
coordinate.&lt;/p&gt;

&lt;p&gt;This is a lazy operation.  Changes to the source image may or may
not be reflected in the cropped image.  To get a separate copy, call
the &lt;b&gt;load&lt;/b&gt; method on the cropped copy.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.draft'&gt;draft&lt;/h3&gt;

&lt;div class='method' id="image-draft-method"&gt;

&lt;p&gt;&lt;b&gt;im.draft(mode, size)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Configures the image file loader so it returns a version of the
image that as closely as possible matches the given mode and size.
For example, you can use this method to convert a colour JPEG to
greyscale while loading it, or to extract a 128x192 version from a PCD
file.&lt;/p&gt;

&lt;p&gt;Note that this method modifies the Image object in place.  If the
image has already been loaded, this method has no effect.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.filter'&gt;filter&lt;/h3&gt;

&lt;div class='method' id="image-filter-method"&gt;

&lt;p&gt;&lt;b&gt;im.filter(filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a copy of an image filtered by the given filter. For a
list of available filters, see the
&lt;a href="imagefilter.htm"&gt;&lt;b&gt;ImageFilter&lt;/b&gt;&lt;/a&gt;
module.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.fromstring'&gt;fromstring&lt;/h3&gt;

&lt;div class='method' id="image-fromstring-method"&gt;

&lt;p&gt;&lt;b&gt;im.fromstring(data)&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;im.fromstring(data, decoder, parameters)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Same as the &lt;b&gt;fromstring&lt;/b&gt; function, but loads data into
the current image.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.getbands'&gt;getbands&lt;/h3&gt;

&lt;div class='method' id="image-getbands-method"&gt;

&lt;p&gt;&lt;b&gt;im.getbands()&lt;/b&gt;
&lt;span&gt;=&gt; tuple of strings&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a tuple containing the name of each band. For example,
&lt;b&gt;getbands&lt;/b&gt; on an RGB image returns ("R", "G", "B").&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.getbbox'&gt;getbbox&lt;/h3&gt;

&lt;div class='method' id="image-getbbox-method"&gt;

&lt;p&gt;&lt;b&gt;im.getbbox()&lt;/b&gt;
&lt;span&gt;=&gt; 4-tuple or None&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Calculates the bounding box of the non-zero regions in the
image. The bounding box is returned as a 4-tuple defining the left,
upper, right, and lower pixel coordinate. If the image is
completely empty, this method returns None.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.getcolors'&gt;getcolors&lt;/h3&gt;

&lt;div class='method' id="image-getcolors-method"&gt;

&lt;p&gt;&lt;b&gt;im.getcolors()&lt;/b&gt;
&lt;span&gt;=&gt; a list of (count, color) tuples or None&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;im.getcolors(maxcolors)&lt;/b&gt;
&lt;span&gt;=&gt; a list of (count, color) tuples or None&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;(New in 1.1.5) Returns an unsorted list of (count, color) tuples,
where the count is the number of times the corresponding color occurs
in the image.&lt;/p&gt;

&lt;p&gt;If the maxcolors value is exceeded, the method stops counting
and returns None.  The default maxcolors value is 256.  To make sure
you get all colors in an image, you can pass in size[0]*size[1] (but
make sure you have lots of memory before you do that on huge images).

&lt;/div&gt;

&lt;h3 id='Image.getdata'&gt;getdata&lt;/h3&gt;

&lt;div class='method' id="image-getdata-method"&gt;

&lt;p&gt;&lt;b&gt;im.getdata()&lt;/b&gt;
&lt;span&gt;=&gt; sequence&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns the contents of an image as a sequence object containing
pixel values.  The sequence object is flattened, so that values for
line one follow directly after the values of line zero, and so
on.&lt;/p&gt;

&lt;p&gt;Note that the sequence object returned by this method is an
internal PIL data type, which only supports certain sequence
operations, including iteration and basic sequence access.  To
convert it to an ordinary sequence (e.g. for printing), use &lt;b&gt;list(im.getdata())&lt;/b&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.getextrema'&gt;getextrema&lt;/h3&gt;

&lt;div class='method' id="image-getextrema-method"&gt;

&lt;p&gt;&lt;b&gt;im.getextrema()&lt;/b&gt;
&lt;span&gt;=&gt; 2-tuple&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a 2-tuple containing the minimum and maximum values of
the image. In the current version of PIL, this is only applicable
to single-band images.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.getpixel'&gt;getpixel&lt;/h3&gt;

&lt;div class='method' id="image-getpixel-method"&gt;

&lt;p&gt;&lt;b&gt;im.getpixel(xy)&lt;/b&gt;
&lt;span&gt;=&gt; value or tuple&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns the pixel at the given position. If the image is a
multi-layer image, this method returns a tuple.&lt;/p&gt;

&lt;p&gt;Note that this method is rather slow; if you need to process larger
parts of an image from Python, you can either use pixel access objects
(see &lt;b&gt;load&lt;/b&gt;), or the &lt;b&gt;getdata&lt;/b&gt; method.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.histogram'&gt;histogram&lt;/h3&gt;

&lt;div class='method' id="image-histogram-method"&gt;

&lt;p&gt;&lt;b&gt;im.histogram()&lt;/b&gt;
&lt;span&gt;=&gt; list&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a histogram for the image. The histogram is returned as a
list of pixel counts, one for each pixel value in the source image. If
the image has more than one band, the histograms for all bands are
concatenated (for example, the histogram for an "RGB" image contains
768 values).&lt;/p&gt;

&lt;p&gt;A bilevel image (mode "1") is treated as a greyscale ("L") image by
this method.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.histogram(mask)&lt;/b&gt;
&lt;span&gt;=&gt; list&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a histogram for those parts of the image where the mask
image is non-zero. The mask image must have the same size as the
image, and be either a bi-level image (mode "1") or a greyscale image
("L").&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.load'&gt;load&lt;/h3&gt;

&lt;div class='method' id="image-load-method"&gt;

&lt;p&gt;&lt;b&gt;im.load()&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Allocates storage for the image and loads it from the file (or from
the source, for lazy operations).  In normal cases, you don't need to
call this method, since the Image class automatically loads an opened
image when it is accessed for the first time.&lt;/p&gt;

&lt;p&gt;(New in 1.1.6) In 1.1.6 and later, &lt;b&gt;load&lt;/b&gt; returns a pixel access
object that can be used to read and modify pixels.  The access object
behaves like a 2-dimensional array, so you can do:&lt;/p&gt;

&lt;pre&gt;
pix = im.load()
print pix[x, y]
pix[x, y] = value
&lt;/div&gt;

&lt;p&gt;Access via this object is a lot faster than &lt;b&gt;getpixel&lt;/b&gt; and
&lt;b&gt;putpixel&lt;/b&gt;.&lt;/p&gt;

&lt;h3 id='Image.offset'&gt;offset&lt;/h3&gt;

&lt;div class='method' id="image-offset-method"&gt;

&lt;p&gt;&lt;b&gt;im.offset(xoffset, yoffset)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;(Deprecated) Returns a copy of the image where the data has been
offset by the given distances. Data wraps around the edges. If yoffset
is omitted, it is assumed to be equal to xoffset.&lt;/p&gt;

&lt;p&gt;This method is deprecated. New code should use the &lt;b&gt;offset&lt;/b&gt;
function in the &lt;a href="pil-imagechops.htm#offset"&gt;&lt;b&gt;ImageChops&lt;/b&gt;&lt;/a&gt;
module.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.paste'&gt;paste&lt;/h3&gt;

&lt;div class='method' id="image-paste-method"&gt;

&lt;p&gt;&lt;b&gt;im.paste(image, box)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Pastes another image into this image. The box argument is either a
2-tuple giving the upper left corner, a 4-tuple defining the left,
upper, right, and lower pixel coordinate, or None (same as (0, 0)).
If a 4-tuple is given, the size of the pasted image must match the
size of the region.&lt;/p&gt;

&lt;p&gt;If the modes don't match, the pasted image is converted to the mode
of this image (see the convert method for details).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.paste(colour, box)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Same as above, but fills the region with a single colour. The
colour is given as a single numerical value for single-band images,
and a tuple for multi-band images.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.paste(image, box, mask)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Same as above, but updates only the regions indicated by the mask.
You can use either "1", "L" or "RGBA" images (in the
latter case, the alpha band is used as mask).  Where the mask is 255,
the given image is copied as is.  Where the mask is 0, the current
value is preserved.  Intermediate values can be used for transparency
effects.&lt;/p&gt;

&lt;p&gt;Note that if you paste an "RGBA" image, the alpha band
is ignored.  You can work around this by using the same image as both
source image and mask.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.paste(colour, box, mask)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Same as above, but fills the region indicated by the mask with a
single colour.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.point'&gt;point&lt;/h3&gt;

&lt;div class='method' id="image-point-method"&gt;

&lt;p&gt;&lt;b&gt;im.point(table)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.point(function)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a copy of the image where each pixel has been mapped
through the given table. The table should contains 256 values per
band in the image. If a function is used instead, it should take a
single argument. The function is called once for each possible
pixel value, and the resulting table is applied to all bands of the
image.&lt;/p&gt;

&lt;p&gt;If the image has mode "I" (integer) or "F" (floating point), you
must use a function, and it must have the following format:&lt;/p&gt;

&lt;pre&gt;
    argument * scale + offset
&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;
    out = im.point(lambda i: i * 1.2 + 10)
&lt;/pre&gt;

&lt;p&gt;You can leave out either the &lt;b&gt;scale&lt;/b&gt; or the &lt;b&gt;offset&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.point(table, mode)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.point(function, mode)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Map the image through table, and convert it on fly. This can be used
to convert "L" and "P" images to "1" in one step, e.g. to threshold an
image.&lt;/p&gt;

&lt;p&gt;(New in 1.1.5) This form can also be used to convert "L" images to
"I" or "F", and to convert "I" images with 16-bit data to "L".  In the
last case, you must use a 65536-item lookup table.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.putalpha'&gt;putalpha&lt;/h3&gt;

&lt;div class='method' id="image-putalpha-method"&gt;

&lt;p&gt;&lt;b&gt;im.putalpha(band)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Copies the given band to the alpha layer of the current image.&lt;/p&gt;

&lt;p&gt;The image must be an "RGBA" image, and the band must be either "L" or "1".&lt;/p&gt;

&lt;p&gt;(New in PIL 1.1.5)  You can use &lt;b&gt;putalpha&lt;/b&gt; on other modes as well;
the image is converted in place, to a mode that matches the current mode
but has an alpha layer (this usually means "LA" or "RGBA"). Also, the band argument can be either an image, or a colour value (an integer).&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.putdata'&gt;putdata&lt;/h3&gt;

&lt;div class='method' id="image-putdata-method"&gt;

&lt;p&gt;&lt;b&gt;im.putdata(data)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.putdata(data, scale, offset)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Copy pixel values from a sequence object into the image, starting
at the upper left corner (0, 0).  The scale and offset values are used
to adjust the sequence values:&lt;/p&gt;

&lt;pre&gt;
    pixel = value * scale + offset
&lt;/pre&gt;

&lt;p&gt;If the scale is omitted, it defaults to 1.0. If the offset is
omitted, it defaults to 0.0.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.putpalette'&gt;putpalette&lt;/h3&gt;

&lt;div class='method' id="image-putpalette-method"&gt;

&lt;p&gt;&lt;b&gt;im.putpalette(sequence)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Attach a palette to a "P" or "L" image. The palette sequence should
contain 768 integer values, where each group of three values represent
the red, green, and blue values for the corresponding pixel index.
Instead of an integer sequence, you can use an 8-bit string.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.putpixel'&gt;putpixel&lt;/h3&gt;

&lt;div class='method' id="image-putpixel-method"&gt;

&lt;p&gt;&lt;b&gt;im.putpixel(xy, colour)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Modifies the pixel at the given position. The colour is given as
a single numerical value for single-band images, and a tuple for
multi-band images.&lt;/p&gt;

&lt;p&gt;Note that this method is relatively slow.  If you're using 1.1.6,
pixel access objects (see &lt;b&gt;load&lt;/b&gt;) provide a faster way to modify
the image.  If you want to generate an entire image, it can be more
efficient to create a Python list and use &lt;b&gt;putdata&lt;/b&gt; to copy it
to the image.  For more extensive changes, use &lt;b&gt;paste&lt;/b&gt; or the
&lt;b&gt;ImageDraw&lt;/b&gt; module instead.&lt;/p&gt;

&lt;p&gt;You can speed &lt;b&gt;putpixel&lt;/b&gt; up a bit by "inlining" the call to the
internal &lt;b&gt;putpixel&lt;/b&gt; implementation method:&lt;/p&gt;

&lt;pre&gt;
    im.load()
    putpixel = im.im.putpixel
    for i in range(n):
       ...
       putpixel((x, y), value)
&lt;/pre&gt;

&lt;p&gt;In 1.1.6, the above is better written as:&lt;/p&gt;

&lt;pre&gt;
    pix = im.load()
    for i in range(n):
        ...
        pix[x, y] = value
&lt;/pre&gt;

&lt;/div&gt;

&lt;h3 id='Image.resize'&gt;resize&lt;/h3&gt;

&lt;div class='method' id="image-resize-method"&gt;

&lt;p&gt;&lt;b&gt;im.resize(size)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.resize(size, filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a resized copy of an image. The size argument gives the
requested size in pixels, as a 2-tuple: (&lt;b&gt;width&lt;/b&gt;,
&lt;b&gt;height&lt;/b&gt;).&lt;/p&gt;

&lt;p&gt;The filter argument can be one of &lt;b&gt;NEAREST&lt;/b&gt; (use nearest
neighbour), &lt;b&gt;BILINEAR&lt;/b&gt; (linear interpolation in a 2x2
environment), &lt;b&gt;BICUBIC&lt;/b&gt; (cubic spline interpolation in a 4x4
environment), or &lt;b&gt;ANTIALIAS&lt;/b&gt; (a high-quality downsampling
filter).  If omitted, or if the image has mode "1" or "P", it is set
to &lt;b&gt;NEAREST&lt;/b&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.rotate'&gt;rotate&lt;/h3&gt;

&lt;div class='method' id="image-rotate-method"&gt;

&lt;p&gt;&lt;b&gt;im.rotate(angle)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.rotate(angle, filter=NEAREST, expand=0)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a copy of an image rotated the given number of degrees
counter clockwise around its centre.&lt;/p&gt;

&lt;p&gt;The filter argument can be one of &lt;b&gt;NEAREST&lt;/b&gt; (use nearest
neighbour), &lt;b&gt;BILINEAR&lt;/b&gt; (linear interpolation in a 2x2
environment), or &lt;b&gt;BICUBIC&lt;/b&gt; (cubic spline interpolation in a 4x4
environment).  If omitted, or if the image has mode "1" or "P", it is
set to &lt;b&gt;NEAREST&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;The expand argument, if true, indicates that the output image should
be made large enough to hold the rotated image.  If omitted or false,
the output image has the same size as the input image.

&lt;/div&gt;

&lt;h3 id='Image.save'&gt;save&lt;/h3&gt;

&lt;div class='method' id="image-save-method"&gt;

&lt;p&gt;&lt;b&gt;im.save(outfile, &lt;i&gt;options...&lt;/i&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.save(outfile, format, &lt;i&gt;options...&lt;/i&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Saves the image under the given filename. If format is omitted,
the format is determined from the filename extension, if possible.
This method returns None.&lt;/p&gt;

&lt;p&gt;Keyword options can be used to provide additional instructions
to the writer. If a writer doesn't recognise an option, it is
silently ignored. The available options are described later in this
handbook.&lt;/p&gt;

&lt;p&gt;You can use a file object instead of a filename. In this case,
you must always specify the format. The file object must implement
the &lt;b&gt;seek&lt;/b&gt;, &lt;b&gt;tell&lt;/b&gt;, and &lt;b&gt;write&lt;/b&gt; methods, and
be opened in binary mode.&lt;/p&gt;

&lt;p&gt;If the save fails, for some reason, the method will raise an
exception (usually an IOError exception).  If this happens, the method
may have created the file, and may have written data to it.  It's up
to your application to remove incomplete files, if necessary.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.seek'&gt;seek&lt;/h3&gt;

&lt;div class='method' id="image-seek-method"&gt;

&lt;p&gt;&lt;b&gt;im.seek(frame)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Seeks to the given frame in a sequence file. If you seek beyond
the end of the sequence, the method raises an &lt;b&gt;EOFError&lt;/b&gt;
exception. When a sequence file is opened, the library
automatically seeks to frame 0.&lt;/p&gt;

&lt;p&gt;Note that in the current version of the library, most sequence
formats only allows you to seek to the next frame.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.show'&gt;show&lt;/h3&gt;

&lt;div class='method' id="image-show-method"&gt;

&lt;p&gt;&lt;b&gt;im.show()&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Displays an image. This method is mainly intended for debugging
purposes.&lt;/p&gt;

&lt;p&gt;On Unix platforms, this method saves the image to a temporary
PPM file, and calls the &lt;b&gt;xv&lt;/b&gt; utility.&lt;/p&gt;

&lt;p&gt;On Windows, it saves the image to a temporary BMP file, and uses
the standard BMP display utility to show it.&lt;/p&gt;

&lt;p&gt;This method returns None.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.split'&gt;split&lt;/h3&gt;

&lt;div class='method' id="image-split-method"&gt;

&lt;p&gt;&lt;b&gt;im.split()&lt;/b&gt;
&lt;span&gt;=&gt; sequence&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a tuple of individual image bands from an image. For
example, splitting an "RGB" image creates three new
images each containing a copy of one of the original bands (red,
green, blue).&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.tell'&gt;tell&lt;/h3&gt;

&lt;div class='method' id="image-tell-method"&gt;

&lt;p&gt;&lt;b&gt;im.tell()&lt;/b&gt;
&lt;span&gt;=&gt; integer&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns the current frame number.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.thumbnail'&gt;thumbnail&lt;/h3&gt;

&lt;div class='method' id="image-thumbnail-method"&gt;

&lt;p&gt;&lt;b&gt;im.thumbnail(size)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.thumbnail(size, filter)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Modifies the image to contain a thumbnail version of itself, no
larger than the given size.  This method calculates an appropriate
thumbnail size to preserve the aspect of the image, calls the
&lt;b&gt;draft&lt;/b&gt; method to configure the file reader (where applicable),
and finally resizes the image.&lt;/p&gt;

&lt;p&gt;The filter argument can be one of &lt;b&gt;NEAREST&lt;/b&gt;, &lt;b&gt;BILINEAR&lt;/b&gt;,
&lt;b&gt;BICUBIC&lt;/b&gt;, or &lt;b&gt;ANTIALIAS&lt;/b&gt; (best quality).  If omitted, it
defaults to &lt;b&gt;NEAREST&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;Note that the bilinear and bicubic filters in the current version
of PIL are not well-suited for thumbnail generation.  You should use
&lt;b&gt;ANTIALIAS&lt;/b&gt; unless speed is much more important than quality.&lt;/p&gt;

&lt;p&gt;Also note that this function modifies the Image object in place.
If you need to use the full resolution image as well, apply this
method to a &lt;b&gt;copy&lt;/b&gt; of the original image.  This method returns
None.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.tobitmap'&gt;tobitmap&lt;/h3&gt;

&lt;div class='method' id="image-tobitmap-method"&gt;

&lt;p&gt;&lt;b&gt;im.tobitmap()&lt;/b&gt;
&lt;span&gt;=&gt; string&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns the image converted to an X11 bitmap.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.tostring'&gt;tostring&lt;/h3&gt;

&lt;div class='method' id="image-tostring-method"&gt;

&lt;p&gt;&lt;b&gt;im.tostring()&lt;/b&gt;
&lt;span&gt;=&gt; string&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a string containing pixel data, using the standard
"raw" encoder.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.tostring(encoder, parameters)&lt;/b&gt;
&lt;span&gt;=&gt; string&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a string containing pixel data, using the given data
encoding.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.transform'&gt;transform&lt;/h3&gt;

&lt;div class='method' id="image-transform-method"&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, method, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, method, data, filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Creates a new image with the given size, and the same mode as
the original, and copies data to the new image using the given
transform.&lt;/p&gt;

&lt;p&gt;In the current version of PIL, the &lt;i&gt;method&lt;/i&gt; argument can be
&lt;b&gt;EXTENT&lt;/b&gt; (cut out a rectangular subregion), &lt;b&gt;AFFINE&lt;/b&gt;
(affine transform), &lt;b&gt;QUAD&lt;/b&gt; (map a quadrilateral to a
rectangle), or &lt;b&gt;MESH&lt;/b&gt; (map a number of source quadrilaterals
in one operation). The various methods are described below.&lt;/p&gt;

&lt;p&gt;The filter argument defines how to filter pixels from the source
image. In the current version, it can be &lt;b&gt;NEAREST&lt;/b&gt; (use nearest
neighbour), &lt;b&gt;BILINEAR&lt;/b&gt; (linear interpolation in a 2x2
environment), or &lt;b&gt;BICUBIC&lt;/b&gt; (cubic spline interpolation in a 4x4
environment). If omitted, or if the image has mode "1" or "P", it is
set to &lt;b&gt;NEAREST&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, EXTENT, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, EXTENT, data, filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Extracts a subregion from the image.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Data&lt;/i&gt; is a 4-tuple (&lt;i&gt;x0, y0, x1, y1&lt;/i&gt;) which specifies
two points in the input image's coordinate system. The resulting
image will contain data sampled from between these two points, such
that (&lt;i&gt;x0, y0&lt;/i&gt;) in the input image will end up at (0,0) in the
output image, and (&lt;i&gt;x1, y1&lt;/i&gt;) at &lt;i&gt;size&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;This method can be used to crop, stretch, shrink, or mirror an
arbitrary rectangle in the current image. It is slightly slower than
&lt;b&gt;crop&lt;/b&gt;, but about as fast as a corresponding &lt;b&gt;resize&lt;/b&gt;
operation.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, AFFINE, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, AFFINE, data, filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Applies an affine transform to the image, and places the result
in a new image with the given size.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Data&lt;/i&gt; is a 6-tuple (&lt;i&gt;a, b, c, d, e, f&lt;/i&gt;) which contain
the first two rows from an affine transform matrix. For each pixel
(&lt;i&gt;x, y&lt;/i&gt;) in the output image, the new value is taken from a
position (a &lt;i&gt;x&lt;/i&gt; + b &lt;i&gt;y&lt;/i&gt; + c, d &lt;i&gt;x&lt;/i&gt; + e &lt;i&gt;y&lt;/i&gt; + f)
in the input image, rounded to nearest pixel.&lt;/p&gt;

&lt;p&gt;This function can be used to scale, translate, rotate, and shear
the original image.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, QUAD, data)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, QUAD, data, filter)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Maps a quadrilateral (a region defined by four corners) from the
image to a rectangle with the given size.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Data&lt;/i&gt; is an 8-tuple (&lt;i&gt;x0, y0, x1, y1, x2, y2, y3,
y3&lt;/i&gt;) which contain the upper left, lower left, lower right, and
upper right corner of the source quadrilateral.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, MESH, data) image&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;im.transform(size, MESH, data, filter) image&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Similar to &lt;b&gt;QUAD&lt;/b&gt;, but data is a list of target
rectangles and corresponding source quadrilaterals.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.transpose'&gt;transpose&lt;/h3&gt;

&lt;div class='method' id="image-transpose-method"&gt;

&lt;p&gt;&lt;b&gt;im.transpose(method)&lt;/b&gt;
&lt;span&gt;=&gt; image&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Returns a flipped or rotated copy of an image.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Method&lt;/i&gt; can be one of the following: &lt;b&gt;FLIP_LEFT_RIGHT&lt;/b&gt;,
&lt;b&gt;FLIP_TOP_BOTTOM&lt;/b&gt;, &lt;b&gt;ROTATE_90&lt;/b&gt;, &lt;b&gt;ROTATE_180&lt;/b&gt;, or
&lt;b&gt;ROTATE_270&lt;/b&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.verify'&gt;verify&lt;/h3&gt;

&lt;div class='method' id="image-verify-method"&gt;

&lt;p&gt;&lt;b&gt;im.verify()&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Attempts to determine if the file is broken, without actually
decoding the image data. If this method finds any problems, it
raises suitable exceptions. This method only works on a newly opened
image; if the image has already been loaded, the result is undefined.
Also, if you need to load the image after using this method, you must
reopen the image file.&lt;/p&gt;

&lt;/div&gt;

&lt;h2&gt;Attributes&lt;/h2&gt;

&lt;p&gt;Instances of the &lt;b&gt;Image&lt;/b&gt; class have the following
attributes:&lt;/p&gt;

&lt;h3 id='Image.format'&gt;format&lt;/h3&gt;

&lt;div class='attribute' id="image-format-attribute"&gt;

&lt;p&gt;&lt;b&gt;im.format&lt;/b&gt;
&lt;span&gt;=&gt; string or None&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The file format of the source file.  For images created by the
library, this attribute is set to None.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.mode'&gt;mode&lt;/h3&gt;

&lt;div class='attribute' id="image-mode-attribute"&gt;

&lt;p&gt;&lt;b&gt;im.mode&lt;/b&gt;
&lt;span&gt;=&gt; string&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Image mode. This is a string specifying the pixel format used by
the image.  Typical values are "1", "L", "RGB", or "CMYK."&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.size'&gt;size&lt;/h3&gt;

&lt;div class='attribute' id="image-size-attribute"&gt;

&lt;p&gt;&lt;b&gt;im.size&lt;/b&gt;
&lt;span&gt;=&gt; (width, height)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Image size, in pixels. The size is given as a 2-tuple (width,
height).&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.palette'&gt;palette&lt;/h3&gt;

&lt;div class='attribute' id="image-palette-attribute"&gt;

&lt;p&gt;&lt;b&gt;im.palette&lt;/b&gt;
&lt;span&gt;=&gt; palette or None&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Colour palette table, if any. If mode is "P", this
should be an instance of the &lt;b&gt;ImagePalette&lt;/b&gt; class.  Otherwise, it
should be set to None.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id='Image.info'&gt;info&lt;/h3&gt;

&lt;div class='attribute' id="image-info-attribute"&gt;

&lt;p&gt;&lt;b&gt;im.info&lt;/b&gt;
&lt;span&gt;=&gt; dictionary&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;A dictionary holding data associated with the image.&lt;/p&gt;

&lt;/div&gt;</textarea>
<table>
<tr><td><label for='author'>Name:</label></td><td>
<div><input name='author' value="" size=40></div>
</td><td>(Optional)</td></tr>
<tr><td><label for='email'>Mail:</label></td><td>
<div><input name='email' value="" size=40></div>
</td><td>(Optional)</td></tr>
<tr><td><label for='note'>Comment:</label></td><td>
<div><input name='note' value="" size=40></div>
</td><td>(Optional)</td></tr>
<tr><td><label for='password'>Password:</label></td><td>
<div><input name='password' value="(replace with the sum of 7+4)" size=40></div>
</td><td>(Required)</td></tr>
</table>
<p>
<input type='submit' name='preview' value='update preview' style='background:#084; color:white; width:200px; font-weight:bold;' >
&nbsp;&nbsp;&nbsp;
<input type='submit' name='submit' value='submit patch'  style='background:#084; color:white; width:200px; font-weight:bold;' >
</p>
<p>&nbsp;</p>
</form>
<div style='background: white; border: 2px solid #084; padding: 0px 20px;'>
<h2>The Image Module</h2>

<!-- LINK PREV concepts.htm -->
<!-- LINK NEXT imagechops.htm -->

<p>The <b>Image</b> module provides a class with the same name which
is used to represent a PIL image. The module also provides a number of
factory functions, including functions to load images from files, and
to create new images.</p>

<h2 id='examples'>Examples</h2>

<p>The following script loads an image, rotates it 45 degrees, and
displays it using an external viewer (usually <b>xv</b> on Unix, and
the <b>paint</b> program on Windows).</p>

<div class='example'>
<b>Open, rotate, and display an image (using the default viewer)</b>
<pre>
from PIL import Image
im = Image.open("bride.jpg")
im.rotate(45).show()
</pre>
</div>

<p>The following script creates nice 128x128 thumbnails of all JPEG
images in the current directory.</p>

<div class='example'>
<b>Create thumbnails</b>
<pre>
from PIL import Image
import glob, os

size = 128, 128

for infile in glob.glob("*.jpg"):
    file, ext = os.path.splitext(infile)
    im = Image.open(infile)
    im.thumbnail(size, Image.ANTIALIAS)
    im.save(file + ".thumbnail", "JPEG")
</pre>
</div>

<h2>Functions</h2>

<h3 id='new'>new</h3>

<div class='function' id='image-new-function'>

<p><b>Image.new(mode, size)</b>
<span>=> image</span></p>

<p><b>Image.new(mode, size, color)</b>
<span>=> image</span></p>

<p>Creates a new image with the given mode and size. Size is given as
a 2-tuple. The colour is given as a single value for single-band
images, and a tuple for multi-band images (with one value for each
band).  If the colour argument is omitted, the image is filled with
black.  If the colour is None, the image is not initialised.</p>

</div>

<h3 id='open'>open</h3>

<div class='function' id="image-open-function">

<p><b>Image.open(infile)</b>
<span>=> image</span></p>

<p><b>Image.open(infile, mode)</b>
<span>=> image</span></p>

<p>Opens and identifies the given image file.  This is a lazy
operation; the actual image data is not read from the file until you
try to process the data (call the <b>load</b> method to force
loading).  If the mode argument is given, it must be "r".</p>

<p>You can use either a string (representing the filename) or a file
object. In the latter case, the file object must implement
<b>read</b>, <b>seek</b>, and <b>tell</b> methods, and be opened in
binary mode.</p>

</div>

<h3 id='blend'>blend</h3>

<div class='function' id="image-blend-function">

<p><b>Image.blend(image1, image2, alpha)</b>
<span>=> image</span></p>

<p>Creates a new image by interpolating between the given images,
using a constant alpha.  Both images must have the same size and
mode.</p>

<pre>
    out = image1 * (1.0 - alpha) + image2 * alpha
</pre>

<p>If alpha is 0.0, a copy of the first image is returned. If alpha
is 1.0, a copy of the second image is returned. There are no
restrictions on the alpha value. If necessary, the result is
clipped to fit into the allowed output range.</p>

</div>

<h3 id='composite'>composite</h3>

<div class='function' id="image-composite-function">

<p><b>Image.composite(image1, image2, mask)</b>
<span>=> image</span></p>

<p>Creates a new image by interpolating between the given images,
using the mask as alpha.  The mask image can have mode "1", "L", or
"RGBA".  All images must be the same size.</p>

</div>

<h3 id='eval'>eval</h3>

<div class='function' id="image-eval-function">

<p><b>Image.eval(image, function)</b>
<span>=> image</span></p>

<p>Applies the function (which should take one argument) to each
pixel in the given image. If the image has more than one band, the
same function is applied to each band. Note that the function is
evaluated once for each possible pixel value, so you cannot use
random components or other generators.</p>

</div>

<h3 id='frombuffer'>frombuffer</h3>

<div class='function' id="image-frombuffer-function">

<p><b>Image.frombuffer(mode, size, data)</b>
<span>=> image</span></p>

<p>(New in PIL 1.1.4).  Creates an image memory from pixel data in a
string or buffer object, using the standard "raw" decoder.  For some
modes, the image memory will share memory with the original buffer
(this means that changes to the original buffer object are reflected
in the image).  Not all modes can share memory; supported modes
include "L", "RGBX", "RGBA", and "CMYK".  For other modes, this
function behaves like a corresponding call to the <b>fromstring</b>
function.</p>

<p class='note'><b>Note:</b> In versions up to 1.1.6, the default
orientation differs from that of <b>fromstring</b>.  This may be
changed in future versions, so for maximum portability, it's
recommended that you spell out all arguments when using the "raw"
decoder:</p>

<pre>
im = Image.frombuffer(mode, size, data, "raw", mode, 0, 1)
</pre>

<p><b>Image.frombuffer(mode, size, data, decoder, parameters)</b>
<span>=> image</span></p>

<p>Same as the corresponding <b>fromstring</b> call.</p>

</div>

<h3 id='fromstring'>fromstring</h3>

<div class='function' id="image-fromstring-function">

<p><b>Image.fromstring(mode, size, data)</b>
<span>=> image</span></p>

<p>Creates an image memory from pixel data in a string, using the
standard "raw" decoder.</p>

<p><b>Image.fromstring(mode, size, data, decoder, parameters)</b>
<span>=> image</span></p>

<p>Same, but allows you to use any pixel decoder supported by PIL.
For more information on available decoders, see the section <a
href="pil-decoder.htm"><i>Writing Your Own File Decoder</i></a>.</p>

<p>Note that this function decodes pixel data, not entire images.  If
you have an entire image file in a string, wrap it in a <b>StringIO</b>
object, and use <a href="#image-open-function"><b>open</b></a>
to load it.</p>

</div>

<h3 id='merge'>merge</h3>

<div class='function' id="image-merge-function">

<p><b>Image.merge(mode, bands)</b>
<span>=> image</span></p>

<p>Creates a new image from a number of single band images. The
bands are given as a tuple or list of images, one for each band
described by the mode. All bands must have the same size.</p>

</div>

<h2>Methods</h2>

<p>An instance of the <b>Image</b> class has the following methods.
Unless otherwise stated, all methods return a new instance of the
<b>Image</b> class, holding the resulting image.</p>

<h3 id='Image.convert'>convert</h3>

<div class='method' id="image-convert-method">

<p><b>im.convert(mode)</b>
<span>=> image</span></p>

<p>Returns a converted copy of an image.</p>

<p>When translating from a palette image, this translates pixels through
the palette. If mode is omitted, a mode is chosen so that all information
in the image and the palette can be represented without a palette.</p>

<p>When from a colour image to black and white, the library uses the
ITU-R 601-2 luma transform:</p>

<pre>
    L = R * 299/1000 + G * 587/1000 + B * 114/1000
</pre>

<p>When converting to a bilevel image (mode "1"), the source image is
first converted to black and white.  Resulting values larger than 127
are then set to white, and the image is dithered.  To use other thresholds,
use the <b>point</b> method.</p>

<p><b>im.convert(mode, matrix)</b>
<span>=> image</span></p>

<p>Converts an "RGB" image to "L" or "RGB" using a conversion
matrix. The matrix is a 4- or 16-tuple.</p>

<p>The following example converts an RGB image (linearly calibrated
according to ITU-R 709, using the D65 luminant) to the CIE XYZ
colour space:</p>

<div class='example'>
<b>Convert RGB to XYZ</b>
<pre>
    rgb2xyz = (
        0.412453, 0.357580, 0.180423, 0,
        0.212671, 0.715160, 0.072169, 0,
        0.019334, 0.119193, 0.950227, 0 )
    out = im.convert("RGB", rgb2xyz)
</pre>
</div>

</div>

<h3 id='Image.copy'>copy</h3>

<div id="image-copy-method" class='method'>

<p><b>im.copy()</b>
<span>=> image</span></p>

<p>Copies the image. Use this method if you wish to paste things
into an image, but still retain the original.</p>

</div>

<h3 id='Image.crop'>crop</h3>

<div id="image-crop-method" class='method'>

<p><b>im.crop(box)</b>
<span>=> image</span></p>

<p>Returns a rectangular region from the current image. The box is
a 4-tuple defining the left, upper, right, and lower pixel
coordinate.</p>

<p>This is a lazy operation.  Changes to the source image may or may
not be reflected in the cropped image.  To get a separate copy, call
the <b>load</b> method on the cropped copy.</p>

</div>

<h3 id='Image.draft'>draft</h3>

<div class='method' id="image-draft-method">

<p><b>im.draft(mode, size)</b></p>

<p>Configures the image file loader so it returns a version of the
image that as closely as possible matches the given mode and size.
For example, you can use this method to convert a colour JPEG to
greyscale while loading it, or to extract a 128x192 version from a PCD
file.</p>

<p>Note that this method modifies the Image object in place.  If the
image has already been loaded, this method has no effect.</p>

</div>

<h3 id='Image.filter'>filter</h3>

<div class='method' id="image-filter-method">

<p><b>im.filter(filter)</b>
<span>=> image</span></p>

<p>Returns a copy of an image filtered by the given filter. For a
list of available filters, see the
<a href="imagefilter.htm"><b>ImageFilter</b></a>
module.</p>

</div>

<h3 id='Image.fromstring'>fromstring</h3>

<div class='method' id="image-fromstring-method">

<p><b>im.fromstring(data)</b></p>
<p><b>im.fromstring(data, decoder, parameters)</b></p>

<p>Same as the <b>fromstring</b> function, but loads data into
the current image.</p>

</div>

<h3 id='Image.getbands'>getbands</h3>

<div class='method' id="image-getbands-method">

<p><b>im.getbands()</b>
<span>=> tuple of strings</span></p>

<p>Returns a tuple containing the name of each band. For example,
<b>getbands</b> on an RGB image returns ("R", "G", "B").</p>

</div>

<h3 id='Image.getbbox'>getbbox</h3>

<div class='method' id="image-getbbox-method">

<p><b>im.getbbox()</b>
<span>=> 4-tuple or None</span></p>

<p>Calculates the bounding box of the non-zero regions in the
image. The bounding box is returned as a 4-tuple defining the left,
upper, right, and lower pixel coordinate. If the image is
completely empty, this method returns None.</p>

</div>

<h3 id='Image.getcolors'>getcolors</h3>

<div class='method' id="image-getcolors-method">

<p><b>im.getcolors()</b>
<span>=> a list of (count, color) tuples or None</span></p>
<p><b>im.getcolors(maxcolors)</b>
<span>=> a list of (count, color) tuples or None</span></p>

<p>(New in 1.1.5) Returns an unsorted list of (count, color) tuples,
where the count is the number of times the corresponding color occurs
in the image.</p>

<p>If the maxcolors value is exceeded, the method stops counting
and returns None.  The default maxcolors value is 256.  To make sure
you get all colors in an image, you can pass in size[0]*size[1] (but
make sure you have lots of memory before you do that on huge images).

</div>

<h3 id='Image.getdata'>getdata</h3>

<div class='method' id="image-getdata-method">

<p><b>im.getdata()</b>
<span>=> sequence</span></p>

<p>Returns the contents of an image as a sequence object containing
pixel values.  The sequence object is flattened, so that values for
line one follow directly after the values of line zero, and so
on.</p>

<p>Note that the sequence object returned by this method is an
internal PIL data type, which only supports certain sequence
operations, including iteration and basic sequence access.  To
convert it to an ordinary sequence (e.g. for printing), use <b>list(im.getdata())</b>.</p>

</div>

<h3 id='Image.getextrema'>getextrema</h3>

<div class='method' id="image-getextrema-method">

<p><b>im.getextrema()</b>
<span>=> 2-tuple</span></p>

<p>Returns a 2-tuple containing the minimum and maximum values of
the image. In the current version of PIL, this is only applicable
to single-band images.</p>

</div>

<h3 id='Image.getpixel'>getpixel</h3>

<div class='method' id="image-getpixel-method">

<p><b>im.getpixel(xy)</b>
<span>=> value or tuple</span></p>

<p>Returns the pixel at the given position. If the image is a
multi-layer image, this method returns a tuple.</p>

<p>Note that this method is rather slow; if you need to process larger
parts of an image from Python, you can either use pixel access objects
(see <b>load</b>), or the <b>getdata</b> method.</p>

</div>

<h3 id='Image.histogram'>histogram</h3>

<div class='method' id="image-histogram-method">

<p><b>im.histogram()</b>
<span>=> list</span></p>

<p>Returns a histogram for the image. The histogram is returned as a
list of pixel counts, one for each pixel value in the source image. If
the image has more than one band, the histograms for all bands are
concatenated (for example, the histogram for an "RGB" image contains
768 values).</p>

<p>A bilevel image (mode "1") is treated as a greyscale ("L") image by
this method.</p>

<p><b>im.histogram(mask)</b>
<span>=> list</span></p>

<p>Returns a histogram for those parts of the image where the mask
image is non-zero. The mask image must have the same size as the
image, and be either a bi-level image (mode "1") or a greyscale image
("L").</p>

</div>

<h3 id='Image.load'>load</h3>

<div class='method' id="image-load-method">

<p><b>im.load()</b></p>

<p>Allocates storage for the image and loads it from the file (or from
the source, for lazy operations).  In normal cases, you don't need to
call this method, since the Image class automatically loads an opened
image when it is accessed for the first time.</p>

<p>(New in 1.1.6) In 1.1.6 and later, <b>load</b> returns a pixel access
object that can be used to read and modify pixels.  The access object
behaves like a 2-dimensional array, so you can do:</p>

<pre>
pix = im.load()
print pix[x, y]
pix[x, y] = value
</div>

<p>Access via this object is a lot faster than <b>getpixel</b> and
<b>putpixel</b>.</p>

<h3 id='Image.offset'>offset</h3>

<div class='method' id="image-offset-method">

<p><b>im.offset(xoffset, yoffset)</b>
<span>=> image</span></p>

<p>(Deprecated) Returns a copy of the image where the data has been
offset by the given distances. Data wraps around the edges. If yoffset
is omitted, it is assumed to be equal to xoffset.</p>

<p>This method is deprecated. New code should use the <b>offset</b>
function in the <a href="pil-imagechops.htm#offset"><b>ImageChops</b></a>
module.</p>

</div>

<h3 id='Image.paste'>paste</h3>

<div class='method' id="image-paste-method">

<p><b>im.paste(image, box)</b></p>

<p>Pastes another image into this image. The box argument is either a
2-tuple giving the upper left corner, a 4-tuple defining the left,
upper, right, and lower pixel coordinate, or None (same as (0, 0)).
If a 4-tuple is given, the size of the pasted image must match the
size of the region.</p>

<p>If the modes don't match, the pasted image is converted to the mode
of this image (see the convert method for details).</p>

<p><b>im.paste(colour, box)</b></p>

<p>Same as above, but fills the region with a single colour. The
colour is given as a single numerical value for single-band images,
and a tuple for multi-band images.</p>

<p><b>im.paste(image, box, mask)</b></p>

<p>Same as above, but updates only the regions indicated by the mask.
You can use either "1", "L" or "RGBA" images (in the
latter case, the alpha band is used as mask).  Where the mask is 255,
the given image is copied as is.  Where the mask is 0, the current
value is preserved.  Intermediate values can be used for transparency
effects.</p>

<p>Note that if you paste an "RGBA" image, the alpha band
is ignored.  You can work around this by using the same image as both
source image and mask.</p>

<p><b>im.paste(colour, box, mask)</b></p>

<p>Same as above, but fills the region indicated by the mask with a
single colour.</p>

</div>

<h3 id='Image.point'>point</h3>

<div class='method' id="image-point-method">

<p><b>im.point(table)</b>
<span>=> image</span></p>

<p><b>im.point(function)</b>
<span>=> image</span></p>

<p>Returns a copy of the image where each pixel has been mapped
through the given table. The table should contains 256 values per
band in the image. If a function is used instead, it should take a
single argument. The function is called once for each possible
pixel value, and the resulting table is applied to all bands of the
image.</p>

<p>If the image has mode "I" (integer) or "F" (floating point), you
must use a function, and it must have the following format:</p>

<pre>
    argument * scale + offset
</pre>

<p>Example:</p>

<pre>
    out = im.point(lambda i: i * 1.2 + 10)
</pre>

<p>You can leave out either the <b>scale</b> or the <b>offset</b>.</p>

<p><b>im.point(table, mode)</b>
<span>=> image</span></p>

<p><b>im.point(function, mode)</b>
<span>=> image</span></p>

<p>Map the image through table, and convert it on fly. This can be used
to convert "L" and "P" images to "1" in one step, e.g. to threshold an
image.</p>

<p>(New in 1.1.5) This form can also be used to convert "L" images to
"I" or "F", and to convert "I" images with 16-bit data to "L".  In the
last case, you must use a 65536-item lookup table.</p>

</div>

<h3 id='Image.putalpha'>putalpha</h3>

<div class='method' id="image-putalpha-method">

<p><b>im.putalpha(band)</b></p>

<p>Copies the given band to the alpha layer of the current image.</p>

<p>The image must be an "RGBA" image, and the band must be either "L" or "1".</p>

<p>(New in PIL 1.1.5)  You can use <b>putalpha</b> on other modes as well;
the image is converted in place, to a mode that matches the current mode
but has an alpha layer (this usually means "LA" or "RGBA"). Also, the band argument can be either an image, or a colour value (an integer).</p>

</div>

<h3 id='Image.putdata'>putdata</h3>

<div class='method' id="image-putdata-method">

<p><b>im.putdata(data)</b></p>

<p><b>im.putdata(data, scale, offset)</b></p>

<p>Copy pixel values from a sequence object into the image, starting
at the upper left corner (0, 0).  The scale and offset values are used
to adjust the sequence values:</p>

<pre>
    pixel = value * scale + offset
</pre>

<p>If the scale is omitted, it defaults to 1.0. If the offset is
omitted, it defaults to 0.0.</p>

</div>

<h3 id='Image.putpalette'>putpalette</h3>

<div class='method' id="image-putpalette-method">

<p><b>im.putpalette(sequence)</b></p>

<p>Attach a palette to a "P" or "L" image. The palette sequence should
contain 768 integer values, where each group of three values represent
the red, green, and blue values for the corresponding pixel index.
Instead of an integer sequence, you can use an 8-bit string.</p>

</div>

<h3 id='Image.putpixel'>putpixel</h3>

<div class='method' id="image-putpixel-method">

<p><b>im.putpixel(xy, colour)</b></p>

<p>Modifies the pixel at the given position. The colour is given as
a single numerical value for single-band images, and a tuple for
multi-band images.</p>

<p>Note that this method is relatively slow.  If you're using 1.1.6,
pixel access objects (see <b>load</b>) provide a faster way to modify
the image.  If you want to generate an entire image, it can be more
efficient to create a Python list and use <b>putdata</b> to copy it
to the image.  For more extensive changes, use <b>paste</b> or the
<b>ImageDraw</b> module instead.</p>

<p>You can speed <b>putpixel</b> up a bit by "inlining" the call to the
internal <b>putpixel</b> implementation method:</p>

<pre>
    im.load()
    putpixel = im.im.putpixel
    for i in range(n):
       ...
       putpixel((x, y), value)
</pre>

<p>In 1.1.6, the above is better written as:</p>

<pre>
    pix = im.load()
    for i in range(n):
        ...
        pix[x, y] = value
</pre>

</div>

<h3 id='Image.resize'>resize</h3>

<div class='method' id="image-resize-method">

<p><b>im.resize(size)</b>
<span>=> image</span></p>

<p><b>im.resize(size, filter)</b>
<span>=> image</span></p>

<p>Returns a resized copy of an image. The size argument gives the
requested size in pixels, as a 2-tuple: (<b>width</b>,
<b>height</b>).</p>

<p>The filter argument can be one of <b>NEAREST</b> (use nearest
neighbour), <b>BILINEAR</b> (linear interpolation in a 2x2
environment), <b>BICUBIC</b> (cubic spline interpolation in a 4x4
environment), or <b>ANTIALIAS</b> (a high-quality downsampling
filter).  If omitted, or if the image has mode "1" or "P", it is set
to <b>NEAREST</b>.</p>

</div>

<h3 id='Image.rotate'>rotate</h3>

<div class='method' id="image-rotate-method">

<p><b>im.rotate(angle)</b>
<span>=> image</span></p>

<p><b>im.rotate(angle, filter=NEAREST, expand=0)</b>
<span>=> image</span></p>

<p>Returns a copy of an image rotated the given number of degrees
counter clockwise around its centre.</p>

<p>The filter argument can be one of <b>NEAREST</b> (use nearest
neighbour), <b>BILINEAR</b> (linear interpolation in a 2x2
environment), or <b>BICUBIC</b> (cubic spline interpolation in a 4x4
environment).  If omitted, or if the image has mode "1" or "P", it is
set to <b>NEAREST</b>.</p>

<p>The expand argument, if true, indicates that the output image should
be made large enough to hold the rotated image.  If omitted or false,
the output image has the same size as the input image.

</div>

<h3 id='Image.save'>save</h3>

<div class='method' id="image-save-method">

<p><b>im.save(outfile, <i>options...</i>)</b></p>

<p><b>im.save(outfile, format, <i>options...</i>)</b></p>

<p>Saves the image under the given filename. If format is omitted,
the format is determined from the filename extension, if possible.
This method returns None.</p>

<p>Keyword options can be used to provide additional instructions
to the writer. If a writer doesn't recognise an option, it is
silently ignored. The available options are described later in this
handbook.</p>

<p>You can use a file object instead of a filename. In this case,
you must always specify the format. The file object must implement
the <b>seek</b>, <b>tell</b>, and <b>write</b> methods, and
be opened in binary mode.</p>

<p>If the save fails, for some reason, the method will raise an
exception (usually an IOError exception).  If this happens, the method
may have created the file, and may have written data to it.  It's up
to your application to remove incomplete files, if necessary.</p>

</div>

<h3 id='Image.seek'>seek</h3>

<div class='method' id="image-seek-method">

<p><b>im.seek(frame)</b></p>

<p>Seeks to the given frame in a sequence file. If you seek beyond
the end of the sequence, the method raises an <b>EOFError</b>
exception. When a sequence file is opened, the library
automatically seeks to frame 0.</p>

<p>Note that in the current version of the library, most sequence
formats only allows you to seek to the next frame.</p>

</div>

<h3 id='Image.show'>show</h3>

<div class='method' id="image-show-method">

<p><b>im.show()</b></p>

<p>Displays an image. This method is mainly intended for debugging
purposes.</p>

<p>On Unix platforms, this method saves the image to a temporary
PPM file, and calls the <b>xv</b> utility.</p>

<p>On Windows, it saves the image to a temporary BMP file, and uses
the standard BMP display utility to show it.</p>

<p>This method returns None.</p>

</div>

<h3 id='Image.split'>split</h3>

<div class='method' id="image-split-method">

<p><b>im.split()</b>
<span>=> sequence</span></p>

<p>Returns a tuple of individual image bands from an image. For
example, splitting an "RGB" image creates three new
images each containing a copy of one of the original bands (red,
green, blue).</p>

</div>

<h3 id='Image.tell'>tell</h3>

<div class='method' id="image-tell-method">

<p><b>im.tell()</b>
<span>=> integer</span></p>

<p>Returns the current frame number.</p>

</div>

<h3 id='Image.thumbnail'>thumbnail</h3>

<div class='method' id="image-thumbnail-method">

<p><b>im.thumbnail(size)</b></p>

<p><b>im.thumbnail(size, filter)</b></p>

<p>Modifies the image to contain a thumbnail version of itself, no
larger than the given size.  This method calculates an appropriate
thumbnail size to preserve the aspect of the image, calls the
<b>draft</b> method to configure the file reader (where applicable),
and finally resizes the image.</p>

<p>The filter argument can be one of <b>NEAREST</b>, <b>BILINEAR</b>,
<b>BICUBIC</b>, or <b>ANTIALIAS</b> (best quality).  If omitted, it
defaults to <b>NEAREST</b>.</p>

<p>Note that the bilinear and bicubic filters in the current version
of PIL are not well-suited for thumbnail generation.  You should use
<b>ANTIALIAS</b> unless speed is much more important than quality.</p>

<p>Also note that this function modifies the Image object in place.
If you need to use the full resolution image as well, apply this
method to a <b>copy</b> of the original image.  This method returns
None.</p>

</div>

<h3 id='Image.tobitmap'>tobitmap</h3>

<div class='method' id="image-tobitmap-method">

<p><b>im.tobitmap()</b>
<span>=> string</span></p>

<p>Returns the image converted to an X11 bitmap.</p>

</div>

<h3 id='Image.tostring'>tostring</h3>

<div class='method' id="image-tostring-method">

<p><b>im.tostring()</b>
<span>=> string</span></p>

<p>Returns a string containing pixel data, using the standard
"raw" encoder.</p>

<p><b>im.tostring(encoder, parameters)</b>
<span>=> string</span></p>

<p>Returns a string containing pixel data, using the given data
encoding.</p>

</div>

<h3 id='Image.transform'>transform</h3>

<div class='method' id="image-transform-method">

<p><b>im.transform(size, method, data)</b>
<span>=> image</span></p>

<p><b>im.transform(size, method, data, filter)</b>
<span>=> image</span></p>

<p>Creates a new image with the given size, and the same mode as
the original, and copies data to the new image using the given
transform.</p>

<p>In the current version of PIL, the <i>method</i> argument can be
<b>EXTENT</b> (cut out a rectangular subregion), <b>AFFINE</b>
(affine transform), <b>QUAD</b> (map a quadrilateral to a
rectangle), or <b>MESH</b> (map a number of source quadrilaterals
in one operation). The various methods are described below.</p>

<p>The filter argument defines how to filter pixels from the source
image. In the current version, it can be <b>NEAREST</b> (use nearest
neighbour), <b>BILINEAR</b> (linear interpolation in a 2x2
environment), or <b>BICUBIC</b> (cubic spline interpolation in a 4x4
environment). If omitted, or if the image has mode "1" or "P", it is
set to <b>NEAREST</b>.</p>

<p><b>im.transform(size, EXTENT, data)</b>
<span>=> image</span></p>

<p><b>im.transform(size, EXTENT, data, filter)</b>
<span>=> image</span></p>

<p>Extracts a subregion from the image.</p>

<p><i>Data</i> is a 4-tuple (<i>x0, y0, x1, y1</i>) which specifies
two points in the input image's coordinate system. The resulting
image will contain data sampled from between these two points, such
that (<i>x0, y0</i>) in the input image will end up at (0,0) in the
output image, and (<i>x1, y1</i>) at <i>size</i>.</p>

<p>This method can be used to crop, stretch, shrink, or mirror an
arbitrary rectangle in the current image. It is slightly slower than
<b>crop</b>, but about as fast as a corresponding <b>resize</b>
operation.</p>

<p><b>im.transform(size, AFFINE, data)</b>
<span>=> image</span></p>

<p><b>im.transform(size, AFFINE, data, filter)</b>
<span>=> image</span></p>

<p>Applies an affine transform to the image, and places the result
in a new image with the given size.</p>

<p><i>Data</i> is a 6-tuple (<i>a, b, c, d, e, f</i>) which contain
the first two rows from an affine transform matrix. For each pixel
(<i>x, y</i>) in the output image, the new value is taken from a
position (a <i>x</i> + b <i>y</i> + c, d <i>x</i> + e <i>y</i> + f)
in the input image, rounded to nearest pixel.</p>

<p>This function can be used to scale, translate, rotate, and shear
the original image.</p>

<p><b>im.transform(size, QUAD, data)</b>
<span>=> image</span></p>

<p><b>im.transform(size, QUAD, data, filter)</b>
<span>=> image</span></p>

<p>Maps a quadrilateral (a region defined by four corners) from the
image to a rectangle with the given size.</p>

<p><i>Data</i> is an 8-tuple (<i>x0, y0, x1, y1, x2, y2, y3,
y3</i>) which contain the upper left, lower left, lower right, and
upper right corner of the source quadrilateral.</p>

<p><b>im.transform(size, MESH, data) image</b>
<span>=> image</span></p>

<p><b>im.transform(size, MESH, data, filter) image</b>
<span>=> image</span></p>

<p>Similar to <b>QUAD</b>, but data is a list of target
rectangles and corresponding source quadrilaterals.</p>

</div>

<h3 id='Image.transpose'>transpose</h3>

<div class='method' id="image-transpose-method">

<p><b>im.transpose(method)</b>
<span>=> image</span></p>

<p>Returns a flipped or rotated copy of an image.</p>

<p><i>Method</i> can be one of the following: <b>FLIP_LEFT_RIGHT</b>,
<b>FLIP_TOP_BOTTOM</b>, <b>ROTATE_90</b>, <b>ROTATE_180</b>, or
<b>ROTATE_270</b>.</p>

</div>

<h3 id='Image.verify'>verify</h3>

<div class='method' id="image-verify-method">

<p><b>im.verify()</b></p>

<p>Attempts to determine if the file is broken, without actually
decoding the image data. If this method finds any problems, it
raises suitable exceptions. This method only works on a newly opened
image; if the image has already been loaded, the result is undefined.
Also, if you need to load the image after using this method, you must
reopen the image file.</p>

</div>

<h2>Attributes</h2>

<p>Instances of the <b>Image</b> class have the following
attributes:</p>

<h3 id='Image.format'>format</h3>

<div class='attribute' id="image-format-attribute">

<p><b>im.format</b>
<span>=> string or None</span></p>

<p>The file format of the source file.  For images created by the
library, this attribute is set to None.</p>

</div>

<h3 id='Image.mode'>mode</h3>

<div class='attribute' id="image-mode-attribute">

<p><b>im.mode</b>
<span>=> string</span></p>

<p>Image mode. This is a string specifying the pixel format used by
the image.  Typical values are "1", "L", "RGB", or "CMYK."</p>

</div>

<h3 id='Image.size'>size</h3>

<div class='attribute' id="image-size-attribute">

<p><b>im.size</b>
<span>=> (width, height)</span></p>

<p>Image size, in pixels. The size is given as a 2-tuple (width,
height).</p>

</div>

<h3 id='Image.palette'>palette</h3>

<div class='attribute' id="image-palette-attribute">

<p><b>im.palette</b>
<span>=> palette or None</span></p>

<p>Colour palette table, if any. If mode is "P", this
should be an instance of the <b>ImagePalette</b> class.  Otherwise, it
should be set to None.</p>

</div>

<h3 id='Image.info'>info</h3>

<div class='attribute' id="image-info-attribute">

<p><b>im.info</b>
<span>=> dictionary</span></p>

<p>A dictionary holding data associated with the image.</p>

</div>
</div>
</body>
</html>
